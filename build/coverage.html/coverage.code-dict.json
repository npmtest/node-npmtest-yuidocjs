{"/home/travis/build/npmtest/node-npmtest-yuidocjs/test.js":"/* istanbul instrument in package npmtest_yuidocjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/lib.npmtest_yuidocjs.js":"/* istanbul instrument in package npmtest_yuidocjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_yuidocjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_yuidocjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-yuidocjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_yuidocjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_yuidocjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_yuidocjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_yuidocjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_yuidocjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_yuidocjs.__dirname + '/lib.npmtest_yuidocjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/index.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\n/**\nModule creates the YUI instance with the required modules, uses them and exports the **Y** to be used\nby the _CLI class_ or by extenders: `require('yuidocjs');`\nYou can use it like this:\n\n    var options = {\n        paths: [ './lib' ],\n        outdir: './out'\n    };\n\n    var Y = require('yuidocjs');\n    var json = (new Y.YUIDoc(options)).run();\n\n@class Main\n@exports {YUI} Y A YUI instance\n@module yuidoc\n*/\n//Hacking in debug support\nvar args = process.argv.slice(2);\nvar debug = false;\n\nargs.forEach(function (item) {\n    if (item.toLowerCase() === '--debug') {\n        debug = true;\n    }\n});\n\nvar YUI = require('yui' + (debug ? '/debug' : '')).YUI;\nvar path = require('path');\nvar fs = require('graceful-fs');\nvar metaPath = path.join(__dirname, '../', 'package.json');\n\nfunction log (message, level) {\n    if (!message || !level || typeof console[level] !== 'function') {\n        return;\n    }\n\n    if (typeof message === 'object') {\n        message = JSON.stringify(message);\n    }\n\n    console[level]('%s: %s', level, message);\n}\n\nprocess.on('uncaughtException', function (msg) {\n    var meta = JSON.parse(fs.readFileSync(metaPath)),\n        inst = YUI(),\n        useColor = (Y ? Y.config.useColor : false);\n\n    inst.applyConfig({\n        debug: true,\n        logFn: log,\n        useColor: useColor\n    });\n\n    inst.log('--------------------------------------------------------------------------', 'error');\n    inst.log('An uncaught YUIDoc error has occurred, stack trace given below', 'error');\n    inst.log('--------------------------------------------------------------------------', 'error');\n    inst.log(msg.stack || msg.message || msg, 'error');\n    inst.log('--------------------------------------------------------------------------', 'error');\n    inst.log('Node.js version: ' + process.version, 'error');\n    inst.log('YUI version: ' + YUI.version, 'error');\n    inst.log('YUIDoc version: ' + meta.version, 'error');\n    inst.log('Please file all tickets here: ' + meta.bugs.url, 'error');\n    inst.log('--------------------------------------------------------------------------', 'error');\n\n    process.exit(1);\n});\n\nvar Y = YUI({\n    modules: {\n        help: {\n            fullpath: path.join(__dirname, 'help.js')\n        },\n        options: {\n            fullpath: path.join(__dirname, 'options.js')\n        },\n        docparser: {\n            fullpath: path.join(__dirname, 'docparser.js'),\n            requires: ['base-base', 'json-stringify']\n        },\n        yuidoc: {\n            fullpath: path.join(__dirname, 'yuidoc.js')\n        },\n        'doc-builder': {\n            fullpath: path.join(__dirname, 'builder.js'),\n            requires: ['parallel', 'handlebars']\n        },\n        utils: {\n            fullpath: path.join(__dirname, 'utils.js')\n        },\n        files: {\n            fullpath: path.join(__dirname, 'files.js')\n        },\n        docview: {\n            fullpath: path.join(__dirname, 'docview.js')\n        },\n        server: {\n            fullpath: path.join(__dirname, 'server.js')\n        },\n        project: {\n            fullpath: path.join(__dirname, 'project.js')\n        }\n    },\n    logExclude: {\n        attribute: true,\n        handlebars: true\n    },\n    logFn: log,\n    useSync: true\n}).use('utils', 'docparser', 'yuidoc', 'doc-builder', 'docview', 'files', 'help', 'options', 'server', 'project');\n\nY.packageInfo = Y.Files.getJSON(metaPath);\n\nmodule.exports = Y;\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/builder.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nvar MarkdownIt = require('markdown-it');\nvar fs = require('graceful-fs');\nvar mdn = require('mdn-links');\nvar noop = function () {};\nvar path = require('path');\nvar TEMPLATE;\n\n/**\n* Takes the `JSON` data from the `DocParser` class, creates and parses markdown and handlebars\nbased templates to generate static HTML content\n* @class DocBuilder\n* @module yuidoc\n*/\n\nYUI.add('doc-builder', function (Y) {\n    var defaultMarkdownOption = {\n        html: true,\n        linkify: true\n    };\n\n    var fixType = Y.Lang.fixType,\n        print = function (items) {\n            var out = '<ul>';\n\n            Y.each(items, function (i, k) {\n                out += '<li>';\n                if (Y.Lang.isObject(i)) {\n                    if (!i.path) {\n                        out += k + '/' + print(i);\n                    } else {\n                        out += '<a href=\"../files/' + i.name + '.html\">' + k + '</a>';\n                    }\n                }\n                out += '</li>';\n            });\n\n            out += '</ul>';\n            return out;\n        };\n\n    Y.Handlebars.registerHelper('buildFileTree', function (items) {\n        return print(items);\n    });\n\n    var DEFAULT_THEME = path.join(__dirname, '../', 'themes', 'default'),\n        themeDir = DEFAULT_THEME;\n\n    Y.DocBuilder = function (options, data) {\n        this.options = options;\n        if (options.helpers) {\n            this._addHelpers(options.helpers);\n        }\n        if (options.themedir) {\n            themeDir = options.themedir;\n        }\n        this.md = new MarkdownIt(Y.merge(defaultMarkdownOption, options.markdown));\n        this.data = data;\n        Y.log('Building..', 'info', 'builder');\n        this.files = 0;\n        var self = this;\n\n        Y.Handlebars.registerHelper('crossLink', function (item, helperOptions) {\n            var str = '';\n            if (!item) {\n                item = '';\n            }\n            //console.log('CrossLink:', item);\n            if (item.indexOf('|') > 0) {\n                var parts = item.split('|'),\n                    p = [];\n                Y.each(parts, function (i) {\n                    p.push(self._parseCrossLink.call(self, i));\n                });\n                str = p.join(' | ');\n            } else {\n                str = self._parseCrossLink.call(self, item, false, helperOptions.fn(this));\n            }\n            return str;\n        });\n\n        Y.Handlebars.registerHelper('crossLinkModule', function (item, helperOptions) {\n            var str = item;\n            if (self.data.modules[item]) {\n                var content = helperOptions.fn(this);\n                if (content === '') {\n                    content = item;\n                }\n                str = '<a href=\"../modules/' + item.replace(/\\//g, '_') +\n                    '.html\">' + content + '</a>';\n            }\n            return str;\n        });\n\n        Y.Handlebars.registerHelper('crossLinkRaw', function (item) {\n            var str = '';\n            if (!item) {\n                item = '';\n            }\n            if (item.indexOf('|') > 0) {\n                var parts = item.split('|'),\n                    p = [];\n                Y.each(parts, function (i) {\n                    p.push(self._parseCrossLink.call(self, i, true));\n                });\n                str = p.join(' | ');\n            } else {\n                str = self._parseCrossLink.call(self, item, true);\n            }\n            return str;\n        });\n\n        this.cacheTemplates = true;\n        if (options.cacheTemplates === false) {\n            this.cacheTemplates = false;\n        }\n    };\n\n    Y.DocBuilder.prototype = {\n        /**\n         * Register a `Y.Handlebars` helper method\n         * @method _addHelpers\n         * @param {Object} helpers Object containing a hash of names and functions\n         */\n        _addHelpers: function (helpers) {\n            Y.log('Importing helpers: ' + helpers, 'info', 'builder');\n            helpers.forEach(function (imp) {\n                if (!Y.Files.exists(imp) || Y.Files.exists(path.join(process.cwd(), imp))) {\n                    imp = path.join(process.cwd(), imp);\n                }\n                var h = require(imp);\n                Object.keys(h).forEach(function (name) {\n                    Y.Handlebars.registerHelper(name, h[name]);\n                });\n            });\n        },\n\n        /**\n         * Wrapper around the Markdown parser so it can be normalized or even side stepped\n         * @method markdown\n         * @private\n         * @param {String} data The Markdown string to parse\n         * @return {HTML} The rendered HTML\n         */\n        markdown: function (data) {\n            var html = this.md.render(data);\n            //Only reprocess if helpers were asked for\n            if (this.options.helpers || (html.indexOf('{{#crossLink') > -1)) {\n                try {\n                    // markdown-it auto-escapes quotation marks (and unfortunately\n                    // does not expose the escaping function)\n                    html = html.replace(/&quot;/g, '\"');\n                    html = (Y.Handlebars.compile(html))({});\n                } catch (hError) {\n                    //Remove all the extra escapes\n                    html = html.replace(/\\\\{/g, '{').replace(/\\\\}/g, '}');\n                    Y.log('Failed to parse Handlebars, probably an unknown helper, skipping..', 'warn', 'builder');\n                }\n            }\n            return html;\n        },\n\n        /**\n         * Parse the item to be cross linked and return an HREF linked to the item\n         * @method _parseCrossLink\n         * @private\n         * @param {String} item The item to crossLink\n         * @param {Boolean} [raw=false] Do not wrap it in HTML\n         * @param {String} [content] crossLink helper content\n         */\n        _parseCrossLink: function (item, raw, content) {\n            var self = this;\n            var parts,\n                base = '../',\n                baseItem,\n                newWin = false,\n                group = /&lt;.*(?=&gt;$)/.test(item) ? 'elements' : 'classes',\n                className = 'crosslink';\n\n            if (group === 'classes') {\n                item = fixType(item);\n            }\n\n            item = baseItem = Y.Lang.trim(item.replace('{', '').replace('}', ''));\n            //Remove Cruft\n            item = item.replace('*', '').replace('[', '').replace(']', '').replace('&lt;', '').replace('&gt;', '');\n\n            var link = false,\n                href;\n\n            if (self.data[group][item]) {\n                link = true;\n            } else {\n                if (self.data[group][item.replace('.', '')]) {\n                    link = true;\n                    item = item.replace('.', '');\n                }\n            }\n            if (self.options.externalData) {\n                if (self.data[group][item]) {\n                    if (self.data[group][item].external) {\n                        href = self.data[group][item].path;\n                        base = self.options.externalData.base;\n                        className += ' external';\n                        newWin = true;\n                        link = true;\n                    }\n                }\n            }\n\n            if (group === 'elements' && item.indexOf(' ') > -1) {\n                // Fragment link for an attribute is required\n                parts = item.split(' ');\n                var el = parts[0],\n                    attr = parts[1];\n\n                if (el && attr) {\n                    if (self.data.elements[el]) {\n                        self.data.elements[el].attributes.some(function (i) {\n                            if (i.name === attr) {\n                                link = true;\n                                baseItem = attr;\n                                href = Y.webpath(base, 'elements', el + '.html#' + attr);\n                            }\n                        });\n                    }\n                }\n            } else if (item.indexOf('/') > -1) {\n                //We have a class + method to parse\n                parts = item.split('/');\n                var cls = parts[0],\n                    method = parts[1],\n                    type = 'method';\n\n                if (method.indexOf(':') > -1) {\n                    parts = method.split(':');\n                    method = parts[0];\n                    type = parts[1];\n                    if (type.indexOf('attr') === 0) {\n                        type = 'attribute';\n                    }\n                }\n\n                if (cls && method) {\n                    if (self.data.classes[cls]) {\n                        self.data.classitems.forEach(function (i) {\n                            if (i.itemtype === type && i.name === method && i.class === cls) {\n                                link = true;\n                                baseItem = method;\n                                var t = type;\n                                if (t === 'attribute') {\n                                    t = 'attr';\n                                }\n                                href = Y.webpath(base, 'classes', cls + '.html#' + t + '_' + method);\n                            }\n                        });\n                    }\n                }\n\n            }\n\n            if (item === 'Object' || item === 'Array') {\n                link = false;\n            }\n            if (!href) {\n                href = Y.webpath(base, group, item + '.html');\n                if (base.match(/^https?:\\/\\//)) {\n                    href = base + Y.webpath(group, item + '.html');\n                }\n            }\n            if (!link && self.options.linkNatives) {\n                href = mdn.getLink.apply(mdn, item.split('/'));\n                if (href) {\n                    className += ' external';\n                    newWin = true;\n                    link = true;\n                }\n            }\n            if (link) {\n                if (content !== undefined) {\n                    content = content.trim();\n                }\n                if (!content) {\n                    content = baseItem;\n                }\n                item = '<a href=\"' + href + '\" class=\"' + className + '\"' + ((newWin) ? ' target=\"_blank\"' : '') + '>' + content + '</a>';\n            }\n            return (raw) ? href : item;\n        },\n\n        /**\n         * Mixes the various external data soures together into the local data, augmenting\n         * it with flags.\n         * @method _mixExternal\n         * @private\n         */\n        _mixExternal: function () {\n            var self = this;\n            Y.log('External data received, mixing', 'info', 'builder');\n            self.options.externalData.forEach(function (exData) {\n\n                ['files', 'elements', 'classes', 'modules'].forEach(function (k) {\n                    Y.each(exData[k], function (item, key) {\n                        item.external = true;\n                        var file = item.name;\n                        if (!item.file) {\n                            file = self.filterFileName(item.name);\n                        }\n\n                        if (item.type) {\n                            item.type = fixType(item.type);\n                        }\n\n                        item.path = exData.base + path.join(k, file + '.html');\n\n                        self.data[k][key] = item;\n                    });\n                });\n                Y.each(exData.classitems, function (item) {\n                    item.external = true;\n                    item.path = exData.base + path.join('files', self.filterFileName(item.file) + '.html');\n                    if (item.type) {\n                        item.type = fixType(item.type);\n                    }\n                    if (item.params) {\n                        item.params.forEach(function (p) {\n                            if (p.type) {\n                                p.type = fixType(p.type);\n                            }\n                        });\n                    }\n                    if (item.return) {\n                        item.return.type = fixType(item.return.type);\n                    }\n                    self.data.classitems.push(item);\n                });\n            });\n        },\n        /**\n         * Fetches the remote data and fires the callback when it's all complete\n         * @method mixExternal\n         * @param {Callback} cb The callback to execute when complete\n         * @async\n         */\n        mixExternal: function (cb) {\n            var self = this,\n                info = self.options.external;\n\n            if (!info) {\n                cb();\n                return;\n            }\n            if (!info.merge) {\n                info.merge = 'mix';\n            }\n            if (!info.data) {\n                Y.log('External config found but no data path defined, skipping import.', 'warn', 'builder');\n                cb();\n                return;\n            }\n            if (!Y.Lang.isArray(info.data)) {\n                info.data = [info.data];\n            }\n            Y.log('Importing external documentation data.', 'info', 'builder');\n\n            var stack = new Y.Parallel();\n            info.data.forEach(function (i) {\n                var base;\n                if (typeof i === 'object') {\n                    base = i.base;\n                    i = i.json;\n                }\n                if (i.match(/^https?:\\/\\//)) {\n                    if (!base) {\n                        base = i.replace('data.json', '');\n                    }\n                    Y.use('io-base', stack.add(function () {\n                        Y.log('Fetching: ' + i, 'info', 'builder');\n                        Y.io(i, {\n                            on: {\n                                complete: stack.add(function (id, e) {\n                                    Y.log('Received: ' + i, 'info', 'builder');\n                                    var parsedData = JSON.parse(e.responseText);\n                                    parsedData.base = base;\n                                    //self.options.externalData = Y.mix(self.options.externalData || {}, data);\n                                    if (!self.options.externalData) {\n                                        self.options.externalData = [];\n                                    }\n                                    self.options.externalData.push(parsedData);\n                                })\n                            }\n                        });\n                    }));\n                } else {\n                    if (!base) {\n                        base = path.dirname(path.resolve(i));\n                    }\n                    var data = Y.Files.getJSON(i);\n                    data.base = base;\n                    //self.options.externalData = Y.mix(self.options.externalData || {}, data);\n                    if (!self.options.externalData) {\n                        self.options.externalData = [];\n                    }\n                    self.options.externalData.push(data);\n                }\n            });\n\n            stack.done(function () {\n                Y.log('Finished fetching remote data', 'info', 'builder');\n                self._mixExternal();\n                cb();\n            });\n        },\n        /**\n         * File counter\n         * @property files\n         * @type Number\n         */\n        files: null,\n        /**\n         * Holder for project meta data\n         * @property _meta\n         * @type Object\n         * @private\n         */\n        _meta: null,\n        /**\n         * Prep the meta data to be fed to Selleck\n         * @method getProjectMeta\n         * @return {Object} The project metadata\n         */\n        getProjectMeta: function () {\n            var obj = {\n                meta: {\n                    yuiSeedUrl: 'http://yui.yahooapis.com/3.5.0/build/yui/yui-min.js',\n                    yuiGridsUrl: 'http://yui.yahooapis.com/3.5.0/build/cssgrids/cssgrids-min.css'\n                }\n            };\n            if (!this._meta) {\n                try {\n                    var meta,\n                        theme = path.join(themeDir, 'theme.json');\n                    if (Y.Files.exists(theme)) {\n                        Y.log('Loading theme from ' + theme, 'info', 'builder');\n                        meta = Y.Files.getJSON(theme);\n                    } else if (DEFAULT_THEME !== themeDir) {\n                        theme = path.join(DEFAULT_THEME, 'theme.json');\n                        if (Y.Files.exists(theme)) {\n                            Y.log('Loading theme from ' + theme, 'info', 'builder');\n                            meta = Y.Files.getJSON(theme);\n                        }\n                    }\n\n                    if (meta) {\n                        obj.meta = meta;\n                        this._meta = meta;\n                    }\n                } catch (e) {\n                    console.error('Error', e);\n                }\n            } else {\n                obj.meta = this._meta;\n            }\n            Y.each(this.data.project, function (v, k) {\n                var key = k.substring(0, 1).toUpperCase() + k.substring(1, k.length);\n                obj.meta['project' + key] = v;\n            });\n            return obj;\n        },\n        /**\n         * Populate the meta data for classes\n         * @method populateClasses\n         * @param {Object} opts The original options\n         * @return {Object} The modified options\n         */\n        populateClasses: function (opts) {\n            opts.meta.classes = [];\n            Y.each(this.data.classes, function (v) {\n                if (v.external) {\n                    return;\n                }\n                opts.meta.classes.push({\n                    displayName: v.name,\n                    name: v.name,\n                    namespace: v.namespace,\n                    module: v.module,\n                    description: v.description,\n                    access: v.access || 'public'\n                });\n            });\n            opts.meta.classes.sort(this.nameSort);\n            return opts;\n        },\n        /**\n         * Populate the meta data for elements\n         * @method populateElements\n         * @param {Object} opts The original options\n         * @return {Object} The modified options\n         */\n        populateElements: function (opts) {\n            opts.meta.elements = [];\n            Y.each(this.data.elements, function (v) {\n                if (v.external) {\n                    return;\n                }\n                opts.meta.elements.push({\n                    displayName: '<' + v.name + '>',\n                    name: v.name,\n                    module: v.module,\n                    description: v.description\n                });\n            });\n            opts.meta.elements.sort(this.nameSort);\n            return opts;\n        },\n        /**\n         * Populate the meta data for modules\n         * @method populateModules\n         * @param {Object} opts The original options\n         * @return {Object} The modified options\n         */\n        populateModules: function (opts) {\n            var self = this;\n            opts.meta.modules = [];\n            opts.meta.allModules = [];\n            Y.each(this.data.modules, function (v) {\n                if (v.external) {\n                    return;\n                }\n                opts.meta.allModules.push({\n                    displayName: v.displayName || v.name,\n                    name: self.filterFileName(v.name),\n                    description: v.description\n                });\n                if (!v.is_submodule) {\n                    var o = {\n                        displayName: v.displayName || v.name,\n                        name: self.filterFileName(v.name)\n                    };\n                    if (v.submodules) {\n                        o.submodules = [];\n                        Y.each(v.submodules, function (i, k) {\n                            var moddef = self.data.modules[k];\n                            if (moddef) {\n                                o.submodules.push({\n                                    displayName: k,\n                                    description: moddef.description\n                                });\n                                // } else {\n                                //     Y.log('Submodule data missing: ' + k + ' for ' + v.name, 'warn', 'builder');\n                            }\n                        });\n                        o.submodules.sort(self.nameSort);\n                    }\n                    opts.meta.modules.push(o);\n                }\n            });\n            opts.meta.modules.sort(this.nameSort);\n            opts.meta.allModules.sort(this.nameSort);\n            return opts;\n        },\n        /**\n         * Populate the meta data for files\n         * @method populateFiles\n         * @param {Object} opts The original options\n         * @return {Object} The modified options\n         */\n        populateFiles: function (opts) {\n            var self = this;\n            opts.meta.files = [];\n            Y.each(this.data.files, function (v) {\n                if (v.external) {\n                    return;\n                }\n                opts.meta.files.push({\n                    displayName: v.name,\n                    name: self.filterFileName(v.name),\n                    path: v.path || v.name\n                });\n            });\n\n            var tree = {};\n            var files = [];\n            Y.each(this.data.files, function (v) {\n                if (v.external) {\n                    return;\n                }\n                files.push(v.name);\n            });\n            files.sort();\n            Y.each(files, function (v) {\n                var p = v.split('/'),\n                    par;\n                p.forEach(function (i, k) {\n                    if (!par) {\n                        if (!tree[i]) {\n                            tree[i] = {};\n                        }\n                        par = tree[i];\n                    } else {\n                        if (!par[i]) {\n                            par[i] = {};\n                        }\n                        if (k + 1 === p.length) {\n                            par[i] = {\n                                path: v,\n                                name: self.filterFileName(v)\n                            };\n                        }\n                        par = par[i];\n                    }\n                });\n            });\n\n            opts.meta.fileTree = tree;\n\n            return opts;\n        },\n        /**\n         * Parses file and line number from an item object and build's an HREF\n         * @method addFoundAt\n         * @param {Object} a The item to parse\n         * @return {String} The parsed HREF\n         */\n        addFoundAt: function (a) {\n            var self = this;\n            if (a.file && a.line && !self.options.nocode) {\n                a.foundAt = '../files/' + self.filterFileName(a.file) + '.html#l' + a.line;\n                if (a.path) {\n                    a.foundAt = a.path + '#l' + a.line;\n                }\n            }\n            return a;\n        },\n        /**\n         * Augments the **DocParser** meta data to provide default values for certain keys as well as parses all descriptions\n         * with the `Markdown Parser`\n         * @method augmentData\n         * @param {Object} o The object to recurse and augment\n         * @return {Object} The augmented object\n         */\n        augmentData: function (o) {\n            var self = this;\n            o = self.addFoundAt(o);\n            Y.each(o, function (i, k1) {\n                if (i && i.forEach) {\n                    Y.each(i, function (a, k) {\n                        if (!(a instanceof Object)) {\n                            return;\n                        }\n                        if (!a.type) {\n                            a.type = 'Object'; //Default type is Object\n                        }\n                        if (a.final === '') {\n                            a.final = true;\n                        }\n                        if (!a.description) {\n                            a.description = ' ';\n                        } else if (!o.extended_from) {\n                            a.description = self.markdown(a.description);\n                        }\n                        if (a.example && !o.extended_from) {\n                            a.example = self.markdown(a.example);\n                        }\n                        a = self.addFoundAt(a);\n\n                        Y.each(a, function (c, d) {\n                            if (c.forEach || (c instanceof Object)) {\n                                c = self.augmentData(c);\n                                a[d] = c;\n                            }\n                        });\n\n                        o[k1][k] = a;\n                    });\n                } else if (i instanceof Object) {\n                    i = self.addFoundAt(i);\n                    Y.each(i, function (v, k) {\n                        if (k === 'final') {\n                            o[k1][k] = true;\n                        } else if (k === 'description' || k === 'example') {\n                            if (v.forEach || (v instanceof Object)) {\n                                o[k1][k] = self.augmentData(v);\n                            } else {\n                                o[k1][k] = o.extended_from ? v : self.markdown(v);\n                            }\n                        }\n                    });\n                } else if (k1 === 'description' || k1 === 'example') {\n                    o[k1] = o.extended_from ? i : self.markdown(i);\n                }\n            });\n            return o;\n        },\n        /**\n         * Makes the default directories needed\n         * @method makeDirs\n         * @param {Callback} cb The callback to execute after it's completed\n         */\n        makeDirs: function (cb) {\n            var self = this;\n            var dirs = ['classes', 'elements', 'modules', 'files'];\n            if (self.options.dumpview) {\n                dirs.push('json');\n            }\n            var writeRedirect = function (dir, file, cbWriteRedirect) {\n                Y.Files.exists(file, function (x) {\n                    if (x) {\n                        var out = path.join(dir, 'index.html');\n                        fs.createReadStream(file).pipe(fs.createWriteStream(out));\n                    }\n                    cbWriteRedirect();\n                });\n            };\n            var defaultIndex = path.join(themeDir, 'assets', 'index.html');\n            var stack = new Y.Parallel();\n            Y.log('Making default directories: ' + dirs.join(','), 'info', 'builder');\n            dirs.forEach(function (d) {\n                var dir = path.join(self.options.outdir, d);\n                Y.Files.exists(dir, stack.add(function (x) {\n                    if (!x) {\n                        fs.mkdir(dir, '0777', stack.add(function () {\n                            writeRedirect(dir, defaultIndex, stack.add(noop));\n                        }));\n                    } else {\n                        writeRedirect(dir, defaultIndex, stack.add(noop));\n                    }\n                }));\n            });\n            stack.done(function () {\n                if (cb) {\n                    cb();\n                }\n            });\n        },\n\n\n        _resolveUrl: function (url, opts) {\n            if (!url) {\n                return null;\n            }\n            if (url.indexOf('://') >= 0) {\n                return url;\n            }\n            return path.join(opts.meta.projectRoot, url);\n        },\n\n        /**\n         * Parses `<pre><code>` tags and adds the __prettyprint__ `className` to them\n         * @method _parseCode\n         * @private\n         * @param {HTML} html The HTML to parse\n         * @return {HTML} The parsed HTML\n         */\n        _parseCode: function (html) {\n            html = html || '';\n            //html = html.replace(/<pre><code>/g, '<pre class=\"code\"><code class=\"prettyprint\">');\n            html = html.replace(/<pre><code/g, '<pre class=\"code prettyprint\"><code');\n            return html;\n        },\n        /**\n        * Ported from [Selleck](https://github.com/rgrove/selleck), this handles ```'s in fields\n        that are not parsed by the **Markdown** parser.\n        * @method _inlineCode\n        * @private\n        * @param {HTML} html The HTML to parse\n        * @return {HTML} The parsed HTML\n        */\n        _inlineCode: function (html) {\n            html = html.replace(/\\\\`/g, '__{{SELLECK_BACKTICK}}__');\n\n            html = html.replace(/`(.+?)`/g, function (match, code) {\n                return '<code>' + Y.escapeHTML(code) + '</code>';\n            });\n\n            html = html.replace(/__\\{\\{SELLECK_BACKTICK\\}\\}__/g, '`');\n\n            return html;\n        },\n        /**\n        * Ported from [Selleck](https://github.com/rgrove/selleck)\n        Renders the handlebars templates with the default View class.\n        * @method render\n        * @param {HTML} source The default template to parse\n        * @param {Class} view The default view handler\n        * @param {HTML} [layout=null] The HTML from the layout to use.\n        * @param {Object} [partials=object] List of partials to include in this template\n        * @param {Callback} callback\n        * @param {Error} callback.err\n        * @param {HTML} callback.html The assembled template markup\n        */\n        render: function (source, view, layout, partials, callback) {\n            var html = [];\n\n            // function buffer(line) {\n            //     html.push(line);\n            // }\n\n            // Allow callback as third or fourth param.\n            if (typeof partials === 'function') {\n                callback = partials;\n                partials = {};\n            } else if (typeof layout === 'function') {\n                callback = layout;\n                layout = null;\n            }\n            var parts = Y.merge(partials || {}, {\n                layout_content: source\n            });\n            Y.each(parts, function (partialsSource, name) {\n                Y.Handlebars.registerPartial(name, partialsSource);\n            });\n\n            if (!TEMPLATE || !this.cacheTemplates) {\n                TEMPLATE = Y.Handlebars.compile(layout);\n            }\n\n\n            var _v = {};\n            for (var k in view) {\n                if (Y.Lang.isFunction(view[k])) {\n                    _v[k] = view[k]();\n                } else {\n                    _v[k] = view[k];\n                }\n            }\n            html = TEMPLATE(_v);\n            //html = html.replace(/{{&#x2F;/g, '{{/');\n\n\n            //html = (Y.Handlebars.compile(html))({});\n\n            html = this._inlineCode(html);\n            callback(null, html);\n        },\n        /**\n         * Render the index file\n         * @method renderIndex\n         * @param {Function} cb The callback fired when complete\n         * @param {String} cb.html The HTML to render this view\n         * @param {Object} cb.view The View Data\n         */\n        renderIndex: function (cb) {\n            var self = this;\n\n            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {\n                if (err) {\n                    Y.log(err, 'error', 'builder');\n                    cb(err);\n                    return;\n                }\n                opts.meta.title = self.data.project.name;\n                opts.meta.projectRoot = './';\n                opts.meta.projectAssets = './assets';\n                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);\n                opts = self.populateClasses(opts);\n                opts = self.populateElements(opts);\n                opts = self.populateModules(opts);\n\n                var view = new Y.DocView(opts.meta);\n                self.render('{{>index}}', view, opts.layouts.main, opts.partials, function (renderErr, html) {\n                    if (renderErr) {\n                        Y.log(renderErr, 'error', 'builder');\n                        cb(renderErr);\n                        return;\n                    }\n                    self.files++;\n                    cb(html, view);\n                });\n            });\n        },\n        /**\n         * Generates the index.html file\n         * @method writeIndex\n         * @param {Callback} cb The callback to execute after it's completed\n         * @param {String} cb.html The HTML to write index view\n         * @param {Object} cb.view The View Data\n         */\n        writeIndex: function (cb) {\n            var self = this,\n                stack = new Y.Parallel();\n\n            Y.log('Preparing index.html', 'info', 'builder');\n            self.renderIndex(stack.add(function (html, view) {\n                stack.html = html;\n                stack.view = view;\n                if (self.options.dumpview) {\n                    Y.Files.writeFile(path.join(self.options.outdir, 'json', 'index.json'), JSON.stringify(view), stack.add(noop));\n                }\n                Y.Files.writeFile(path.join(self.options.outdir, 'index.html'), html, stack.add(noop));\n            }));\n\n            stack.done(function ( /* html, view */ ) {\n                Y.log('Writing index.html', 'info', 'builder');\n                cb(stack.html, stack.view);\n            });\n        },\n        /**\n         * Render a module\n         * @method renderModule\n         * @param {Function} cb The callback fired when complete\n         * @param {String} cb.html The HTML to render this view\n         * @param {Object} cb.view The View Data\n         */\n        renderModule: function (cb, data, layout) {\n            var self = this;\n            var stack = new Y.Parallel();\n\n            data.displayName = data.name;\n            data.name = self.filterFileName(data.name);\n            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {\n                if (err) {\n                    Y.log(err, 'error', 'builder');\n                    cb(err);\n                    return;\n                }\n                opts.meta = Y.merge(opts.meta, data);\n\n                //opts.meta.htmlTitle = v.name + ': ' + self.data.project.name;\n                opts.meta.title = self.data.project.name;\n\n                opts.meta.moduleName = data.displayName || data.name;\n                opts.meta.moduleDescription = self._parseCode(self.markdown(data.description || ' '));\n                opts.meta.file = data.file;\n                opts.meta.line = data.line;\n                opts.meta = self.addFoundAt(opts.meta);\n                opts.meta.projectRoot = '../';\n                opts.meta.projectAssets = '../assets';\n                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);\n                opts = self.populateClasses(opts);\n                opts = self.populateElements(opts);\n                opts = self.populateModules(opts);\n                opts = self.populateFiles(opts);\n\n                if (data.classes && Object.keys(data.classes).length) {\n                    opts.meta.moduleClasses = [];\n                    Y.each(Object.keys(data.classes), function (name) {\n                        var i = self.data.classes[name];\n                        if (i) {\n                            opts.meta.moduleClasses.push({\n                                name: i.name,\n                                displayName: i.name\n                            });\n                        }\n                    });\n                    opts.meta.moduleClasses.sort(self.nameSort);\n                }\n                if (data.elements && Object.keys(data.elements).length) {\n                    opts.meta.moduleElements = [];\n                    Y.each(Object.keys(data.elements), function (name) {\n                        var i = self.data.elements[name];\n                        if (i) {\n                            opts.meta.moduleElements.push({\n                                name: i.name,\n                                displayName: i.name\n                            });\n                        }\n                    });\n                    opts.meta.moduleElements.sort(self.nameSort);\n                }\n                if (data.example && data.example.length) {\n                    if (data.example.forEach) {\n                        var e = '';\n                        data.example.forEach(function (v) {\n                            e += self._parseCode(self.markdown(v));\n                        });\n                        data.example = e;\n                    } else {\n                        data.example = self._parseCode(self.markdown(data.example));\n                    }\n                    opts.meta.example = data.example;\n                }\n                if (data.submodules && Object.keys(data.submodules).length) {\n                    opts.meta.subModules = [];\n                    Y.each(Object.keys(data.submodules), function (name) {\n                        var i = self.data.modules[name];\n                        if (i) {\n                            opts.meta.subModules.push({\n                                name: i.name,\n                                displayName: i.name,\n                                description: i.description\n                            });\n                        }\n                    });\n                    opts.meta.subModules.sort(self.nameSort);\n                }\n\n                var view = new Y.DocView(opts.meta);\n                var mainLayout = opts.layouts[layout];\n                self.render('{{>module}}', view, mainLayout, opts.partials, stack.add(function (renderErr, html) {\n                    if (renderErr) {\n                        Y.log(renderErr, 'error', 'builder');\n                        cb(renderErr);\n                        return;\n                    }\n                    self.files++;\n                    stack.html = html;\n                    stack.view = view;\n                }));\n            });\n\n            stack.done(function () {\n                cb(stack.html, stack.view);\n            });\n        },\n        /**\n         * Generates the module files under \"out\"/modules/\n         * @method writeModules\n         * @param {Callback} cb The callback to execute after it's completed\n         * @param {String} cb.html The HTML to write module view\n         * @param {Object} cb.view The View Data\n         */\n        writeModules: function (cb, layout) {\n            layout = layout || 'main';\n            var self = this,\n                stack = new Y.Parallel();\n            stack.html = [];\n            stack.view = [];\n\n            var counter = 0;\n            Object.keys(self.data.modules).forEach(function (k) {\n                if (!self.data.modules[k].external) {\n                    counter++;\n                }\n            });\n            Y.log('Rendering and writing ' + counter + ' modules pages.', 'info', 'builder');\n            Y.each(self.data.modules, function (v) {\n                if (v.external) {\n                    return;\n                }\n                self.renderModule(function (html, view) {\n                    stack.html.push(html);\n                    stack.view.push(view);\n                    if (self.options.dumpview) {\n                        Y.Files.writeFile(\n                            path.join(self.options.outdir, 'json', 'module_' + v.name + '.json'),\n                            JSON.stringify(view),\n                            stack.add(noop)\n                        );\n                    }\n                    Y.Files.writeFile(path.join(self.options.outdir, 'modules', v.name + '.html'), html, stack.add(noop));\n                }, v, layout);\n            });\n            stack.done(function () {\n                Y.log('Finished writing module files', 'info', 'builder');\n                cb(stack.html, stack.view);\n            });\n        },\n        /**\n         * Checks an array of items (class items) to see if an item is in that list\n         * @method hasProperty\n         * @param {Array} a The Array of items to check\n         * @param {Object} b The object to find\n         * @return Boolean\n         */\n        hasProperty: function (a, b) {\n            var other = false;\n            Y.some(a, function (i, k) {\n                if ((i.itemtype === b.itemtype) && (i.name === b.name)) {\n                    other = k;\n                    return true;\n                }\n            });\n            return other;\n        },\n        /**\n         * Counter for stepping into merges\n         * @private\n         * @property _mergeCounter\n         * @type Number\n         */\n        _mergeCounter: null,\n        /**\n         * Merge superclass data into a child class\n         * @method mergeExtends\n         * @param {Object} info The item to extend\n         * @param {Array} classItems The list of items to merge in\n         * @param {Boolean} first Set for the first call\n         */\n        mergeExtends: function (info, classItems, first) {\n            var self = this;\n            self._mergeCounter = (first) ? 0 : (self._mergeCounter + 1);\n\n            if (self._mergeCounter === 100) {\n                throw ('YUIDoc detected a loop extending class ' + info.name);\n            }\n            if (info.extends || info.uses) {\n                var hasItems = {};\n                hasItems[info.extends] = 1;\n                if (info.uses) {\n                    info.uses.forEach(function (v) {\n                        hasItems[v] = 1;\n                    });\n                }\n                self.data.classitems.forEach(function (v) {\n                    //console.error(v.class, '==', info.extends);\n                    if (hasItems[v.class]) {\n                        if (!v.static) {\n                            var q,\n                                override = self.hasProperty(classItems, v);\n                            if (override === false) {\n                                //This method was extended from the parent class but not over written\n                                //console.error('Merging extends from', v.class, 'onto', info.name);\n                                q = Y.merge({}, v);\n                                q.extended_from = v.class;\n                                classItems.push(q);\n                            } else {\n                                //This method was extended from the parent and overwritten in this class\n                                q = Y.merge({}, v);\n                                q = self.augmentData(q);\n                                classItems[override].overwritten_from = q;\n                            }\n                        }\n                    }\n                });\n                if (self.data.classes[info.extends]) {\n                    if (self.data.classes[info.extends].extends || self.data.classes[info.extends].uses) {\n                        //console.error('Stepping down to:', self.data.classes[info.extends]);\n                        classItems = self.mergeExtends(self.data.classes[info.extends], classItems);\n                    }\n                }\n            }\n            return classItems;\n        },\n        /**\n         * Render the class file\n         * @method renderClass\n         * @param {Function} cb The callback fired when complete\n         * @param {String} cb.html The HTML to render this view\n         * @param {Object} cb.view The View Data\n         */\n        renderClass: function (cb, data, layout) {\n            var self = this;\n            var stack = new Y.Parallel();\n\n            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {\n                //console.log(opts);\n                if (err) {\n                    console.log(err);\n                }\n                opts.meta = Y.merge(opts.meta, data);\n\n                opts.meta.title = self.data.project.name;\n                opts.meta.moduleName = data.name;\n                opts.meta.file = data.file;\n                opts.meta.line = data.line;\n                opts.meta = self.addFoundAt(opts.meta);\n                opts.meta.projectRoot = '../';\n                opts.meta.projectAssets = '../assets';\n                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);\n\n                opts = self.populateClasses(opts);\n                opts = self.populateElements(opts);\n                opts = self.populateModules(opts);\n                opts = self.populateFiles(opts);\n\n                opts.meta.classDescription = self._parseCode(self.markdown(data.description || ' '));\n\n                opts.meta.methods = [];\n                opts.meta.properties = [];\n                opts.meta.attrs = [];\n                opts.meta.events = [];\n                opts.meta.extension_for = null;\n                if (data.uses) {\n                    opts.meta.uses = data.uses;\n                }\n                if (data.entension_for && data.extension_for.length) {\n                    opts.meta.extension_for = data.extension_for;\n                }\n\n                if (data.extends) {\n                    opts.meta.extends = data.extends;\n                }\n\n                var classItems = [];\n                self.data.classitems.forEach(function (classItem) {\n                    if (classItem.class === data.name) {\n                        classItems.push(classItem);\n                    }\n                });\n\n                classItems = self.mergeExtends(data, classItems, true);\n\n                if (data.is_constructor) {\n                    var constructor = Y.mix({}, data);\n                    constructor = self.augmentData(constructor);\n                    constructor.paramsList = [];\n                    if (constructor.params) {\n                        constructor.params.forEach(function (p) {\n                            var name = p.name;\n                            if (p.optional) {\n                                name = '[' + name + ((p.optdefault) ? '=' + p.optdefault : '') + ']';\n                            }\n                            constructor.paramsList.push(name);\n                        });\n                    }\n                    //i.methodDescription = self._parseCode(markdown(i.description));\n                    constructor.hasAccessType = constructor.access;\n                    constructor.hasParams = constructor.paramsList.length;\n                    if (constructor.paramsList.length) {\n                        constructor.paramsList = constructor.paramsList.join(', ');\n                    } else {\n                        constructor.paramsList = ' ';\n                    }\n                    constructor.returnType = ' ';\n                    if (constructor.return) {\n                        constructor.hasReturn = true;\n                        constructor.returnType = constructor.return.type;\n                    }\n                    //console.error(i);\n                    opts.meta.is_constructor = [constructor];\n                    if (constructor.example && constructor.example.length) {\n                        if (constructor.example.forEach) {\n                            var example = '';\n                            constructor.example.forEach(function (v) {\n                                example += self._parseCode(self.markdown(v));\n                            });\n                            constructor.example = example;\n                        } else {\n                            constructor.example = self._parseCode(self.markdown(constructor.example));\n                        }\n                    }\n                }\n\n                classItems.forEach(function (i) {\n                    var e;\n                    switch (i.itemtype) {\n                    case 'method':\n                        i = self.augmentData(i);\n                        i.paramsList = [];\n                        if (i.params && i.params.forEach) {\n                            i.params.forEach(function (p) {\n                                var name = p.name;\n                                if (p.optional) {\n                                    name = '[' + name + ((p.optdefault) ? '=' + p.optdefault : '') + ']';\n                                }\n                                i.paramsList.push(name);\n                            });\n                        }\n                        i.methodDescription = self._parseCode(i.description);\n                        if (i.example && i.example.length) {\n                            if (i.example.forEach) {\n                                e = '';\n                                i.example.forEach(function (v) {\n                                    e += self._parseCode(self.markdown(v));\n                                });\n                                i.example = e;\n                            } else if (!i.extended_from) {\n                                i.example = self._parseCode(self.markdown(i.example));\n                            }\n                        }\n                        i.hasAccessType = i.access;\n                        i.hasParams = i.paramsList.length;\n                        if (i.paramsList.length) {\n                            i.paramsList = i.paramsList.join(', ');\n                        } else {\n                            i.paramsList = ' ';\n                        }\n                        i.returnType = ' ';\n                        if (i.return) {\n                            i.hasReturn = true;\n                            i.returnType = i.return.type;\n                        }\n\n                        // If this item is provided by a module other\n                        // than the module that provided the original\n                        // class, add the original module name to the\n                        // item's `providedBy` property so we can\n                        // indicate the relationship.\n                        if ((i.submodule || i.module) !== (data.submodule || data.module)) {\n                            i.providedBy = (i.submodule || i.module);\n                        }\n\n                        opts.meta.methods.push(i);\n                        break;\n                    case 'property':\n                        i = self.augmentData(i);\n                        //i.propertyDescription = self._parseCode(markdown(i.description || ''));\n                        i.propertyDescription = self._parseCode(i.description);\n                        if (!i.type) {\n                            i.type = 'unknown';\n                        }\n                        if (i.final === '') {\n                            i.final = true;\n                        }\n                        if (i.example && i.example.length) {\n                            if (i.example.forEach) {\n                                e = '';\n                                i.example.forEach(function (v) {\n                                    e += self._parseCode(self.markdown(v));\n                                });\n                                i.example = e;\n                            } else {\n                                i.example = self._parseCode(self.markdown(i.example));\n                            }\n                        }\n\n                        // If this item is provided by a module other\n                        // than the module that provided the original\n                        // class, add the original module name to the\n                        // item's `providedBy` property so we can\n                        // indicate the relationship.\n                        if ((i.submodule || i.module) !== (data.submodule || data.module)) {\n                            i.providedBy = (i.submodule || i.module);\n                        }\n\n                        opts.meta.properties.push(i);\n                        break;\n\n                    case 'attribute': // fallthru\n                    case 'config':\n                        i = self.augmentData(i);\n                        //i.attrDescription = self._parseCode(markdown(i.description || ''));\n                        i.attrDescription = self._parseCode(i.description);\n\n                        if (i.itemtype === 'config') {\n                            i.config = true;\n                        } else {\n                            i.emit = self.options.attributesEmit;\n                        }\n                        if (i.readonly === '') {\n                            i.readonly = true;\n                        }\n\n                        if (i.example && i.example.length) {\n                            if (i.example.forEach) {\n                                e = '';\n                                i.example.forEach(function (v) {\n                                    e += self._parseCode(self.markdown(v));\n                                });\n                                i.example = e;\n                            } else {\n                                i.example = self._parseCode(self.markdown(i.example));\n                            }\n                        }\n\n                        // If this item is provided by a module other\n                        // than the module that provided the original\n                        // class, add the original module name to the\n                        // item's `providedBy` property so we can\n                        // indicate the relationship.\n                        if ((i.submodule || i.module) !== (data.submodule || data.module)) {\n                            i.providedBy = (i.submodule || i.module);\n                        }\n\n                        opts.meta.attrs.push(i);\n                        break;\n                    case 'event':\n                        i = self.augmentData(i);\n                        //i.eventDescription = self._parseCode(markdown(i.description || ''));\n                        i.eventDescription = self._parseCode(i.description);\n\n                        if (i.example && i.example.length) {\n                            if (i.example.forEach) {\n                                e = '';\n                                i.example.forEach(function (v) {\n                                    e += self._parseCode(self.markdown(v));\n                                });\n                                i.example = e;\n                            } else {\n                                i.example = self._parseCode(self.markdown(i.example));\n                            }\n                        }\n\n                        // If this item is provided by a module other\n                        // than the module that provided the original\n                        // class, add the original module name to the\n                        // item's `providedBy` property so we can\n                        // indicate the relationship.\n                        if ((i.submodule || i.module) !== (data.submodule || data.module)) {\n                            i.providedBy = (i.submodule || i.module);\n                        }\n\n                        opts.meta.events.push(i);\n                        break;\n                    }\n                });\n\n                if (!self.options.dontsortfields) {\n                    opts.meta.attrs.sort(self.nameSort);\n                    opts.meta.events.sort(self.nameSort);\n                    opts.meta.methods.sort(self.nameSort);\n                    opts.meta.properties.sort(self.nameSort);\n                }\n\n                if (!opts.meta.methods.length) {\n                    delete opts.meta.methods;\n                }\n                if (!opts.meta.properties.length) {\n                    delete opts.meta.properties;\n                }\n                if (!opts.meta.attrs.length) {\n                    delete opts.meta.attrs;\n                }\n                if (!opts.meta.events.length) {\n                    delete opts.meta.events;\n                }\n\n                var view = new Y.DocView(opts.meta);\n                var mainLayout = opts.layouts[layout];\n                self.render('{{>classes}}', view, mainLayout, opts.partials, stack.add(function (renderErr, html) {\n                    if (renderErr) {\n                        Y.log(renderErr, 'error', 'builder');\n                        cb(renderErr);\n                        return;\n                    }\n                    self.files++;\n                    stack.html = html;\n                    stack.view = view;\n                    stack.opts = opts;\n                }));\n            });\n\n            stack.done(function () {\n                cb(stack.html, stack.view, stack.opts);\n            });\n        },\n        /**\n         * Render the element file\n         * @method renderElement\n         * @param {Function} cb The callback fired when complete\n         * @param {String} cb.html The HTML to render this view\n         * @param {Object} cb.view The View Data\n         */\n        renderElement: function (cb, data, layout) {\n            var self = this;\n            var stack = new Y.Parallel();\n\n            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {\n                if (err) {\n                    console.log(err);\n                }\n                opts.meta = Y.merge(opts.meta, data);\n\n                opts.meta.title = self.data.project.name;\n                opts.meta.moduleName = data.name;\n                opts.meta.file = data.file;\n                opts.meta.line = data.line;\n                opts.meta = self.addFoundAt(opts.meta);\n                opts.meta.projectRoot = '../';\n                opts.meta.projectAssets = '../assets';\n                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);\n\n                opts = self.populateClasses(opts);\n                opts = self.populateElements(opts);\n                opts = self.populateModules(opts);\n                opts = self.populateFiles(opts);\n\n                opts.meta.elementDescription = self._parseCode(self.markdown(data.description || ' '));\n\n                if (data.example && data.example.length) {\n                    if (data.example.forEach) {\n                        var e = '';\n                        data.example.forEach(function (v) {\n                            e += self._parseCode(self.markdown(v));\n                        });\n                        data.example = e;\n                    } else {\n                        data.example = self._parseCode(self.markdown(data.example));\n                    }\n                    opts.meta.example = data.example;\n                }\n\n                if (!self.options.dontsortfields) {\n                    opts.meta.attributes.sort(self.nameSort);\n                }\n\n                opts.meta.attributes.forEach(function (a) {\n                    a.description = self._parseCode(a.description);\n                });\n\n                if (!opts.meta.attributes.length) {\n                    delete opts.meta.attributes;\n                }\n\n                var view = new Y.DocView(opts.meta);\n                var mainLayout = opts.layouts[layout];\n                self.render('{{>elements}}', view, mainLayout, opts.partials, stack.add(function (renderErr, html) {\n                    if (renderErr) {\n                        Y.log(renderErr, 'error', 'builder');\n                        cb(renderErr);\n                        return;\n                    }\n                    self.files++;\n                    stack.html = html;\n                    stack.view = view;\n                    stack.opts = opts;\n                }));\n            });\n\n            stack.done(function () {\n                cb(stack.html, stack.view, stack.opts);\n            });\n        },\n        /**\n         * Generates the class or element files under \"out\"/classes/ or \"out\"/elements/\n         * @method writeComponents\n         * @param {String} type The component type, \"classes\" or \"elements\"\n         * @param {Callback} cb The callback to execute after it's completed\n         * @param {String} cb.html The HTML to write class view\n         * @param {Object} cb.view The View Data\n         */\n        writeComponents: function (type, cb, layout) {\n            layout = layout || 'main';\n            var self = this,\n                stack = new Y.Parallel();\n            stack.html = [];\n            stack.view = [];\n\n            var counter = 0;\n            Object.keys(self.data[type]).forEach(function (k) {\n                if (!self.data[type][k].external) {\n                    counter++;\n                }\n            });\n            Y.log('Rendering and writing ' + counter + ' class pages.', 'info', 'builder');\n            Y.each(self.data[type], function (v) {\n                if (v.external) {\n                    return;\n                }\n                self[type === 'classes' ? 'renderClass' : 'renderElement'](stack.add(function (html, view) {\n                    stack.html.push(html);\n                    stack.view.push(view);\n                    if (self.options.dumpview) {\n                        Y.Files.writeFile(\n                            path.join(self.options.outdir, 'json', type + '_' + v.name + '.json'),\n                            JSON.stringify(view),\n                            stack.add(noop)\n                        );\n                    }\n                    Y.Files.writeFile(path.join(self.options.outdir, type, v.name + '.html'), html, stack.add(noop));\n                }), v, layout);\n            });\n            stack.done(function () {\n                Y.log('Finished writing ' + type.replace(/e?s$/, '') + ' files', 'info', 'builder');\n                cb(stack.html, stack.view);\n            });\n        },\n        /**\n         * Sort method of array of objects with a property called __name__\n         * @method nameSort\n         * @param {Object} a First object to compare\n         * @param {Object} b Second object to compare\n         * @return {Number} 1, -1 or 0 for sorting.\n         */\n        nameSort: function (a, b) {\n            if (!a.name || !b.name) {\n                return 0;\n            }\n            var an = a.name.toLowerCase(),\n                bn = b.name.toLowerCase(),\n                ret = 0;\n\n            if (an < bn) {\n                ret = -1;\n            }\n            if (an > bn) {\n                ret = 1;\n            }\n            return ret;\n        },\n        /**\n         * Generates the syntax files under `\"out\"/files/`\n         * @method writeFiles\n         * @param {Callback} cb The callback to execute after it's completed\n         * @param {String} cb.html The HTML to write file view\n         * @param {Object} cb.view The View Data\n         */\n        writeFiles: function (cb, layout) {\n            layout = layout || 'main';\n            var self = this,\n                stack = new Y.Parallel();\n            stack.html = [];\n            stack.view = [];\n\n            var counter = 0;\n            Object.keys(self.data.files).forEach(function (k) {\n                if (!self.data.files[k].external) {\n                    counter++;\n                }\n            });\n            Y.log('Rendering and writing ' + counter + ' source files.', 'info', 'builder');\n            Y.each(self.data.files, function (v) {\n                if (v.external) {\n                    return;\n                }\n                self.renderFile(stack.add(function (html, view, data) {\n                    if (!view || !data) {\n                        return;\n                    }\n                    stack.html.push(html);\n                    stack.view.push(view);\n                    if (self.options.dumpview) {\n                        Y.Files.writeFile(\n                            path.join(self.options.outdir, 'json', 'files_' + self.filterFileName(data.name) + '.json'),\n                            JSON.stringify(view),\n                            stack.add(noop)\n                        );\n                    }\n                    Y.Files.writeFile(\n                        path.join(self.options.outdir, 'files', self.filterFileName(data.name) + '.html'),\n                        html,\n                        stack.add(noop)\n                    );\n                }), v, layout);\n            });\n            stack.done(function () {\n                Y.log('Finished writing source files', 'info', 'builder');\n                cb(stack.html, stack.view);\n            });\n        },\n        /**\n         * Render the source file\n         * @method renderFile\n         * @param {Function} cb The callback fired when complete\n         * @param {String} cb.html The HTML to render this view\n         * @param {Object} cb.view The View Data\n         */\n        renderFile: function (cb, data, layout) {\n            var self = this;\n\n            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {\n                if (err) {\n                    console.log(err);\n                }\n                if (!data.name) {\n                    return;\n                }\n\n                opts.meta = Y.merge(opts.meta, data);\n\n                opts.meta.title = self.data.project.name;\n                opts.meta.moduleName = data.name;\n                opts.meta.projectRoot = '../';\n                opts.meta.projectAssets = '../assets';\n                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);\n\n                opts = self.populateClasses(opts);\n                opts = self.populateModules(opts);\n                opts = self.populateFiles(opts);\n\n                opts.meta.fileName = data.name;\n                fs.readFile(opts.meta.fileName, Y.charset, Y.rbind(function (readErr, str, readOpts, readData) {\n                    if (readErr) {\n                        Y.log(readErr, 'error', 'builder');\n                        cb(readErr);\n                        return;\n                    }\n\n                    if (typeof self.options.tabspace === 'string') {\n                        str = str.replace(/\\t/g, self.options.tabspace);\n                    }\n\n                    readOpts.meta.fileData = str;\n                    var view = new Y.DocView(readOpts.meta, 'index');\n                    var mainLayout = readOpts.layouts[layout];\n                    self.render('{{>files}}', view, mainLayout, readOpts.partials, function (renderErr, html) {\n                        if (renderErr) {\n                            Y.log(renderErr, 'error', 'builder');\n                            cb(renderErr);\n                            return;\n                        }\n                        self.files++;\n                        cb(html, view, readData);\n                    });\n\n                }, this, opts, data));\n            });\n\n        },\n        /**\n         * Write the API meta data used for the AutoComplete widget\n         * @method writeAPIMeta\n         * @param {Callback} cb The callback to execute when complete\n         * @async\n         */\n        writeAPIMeta: function (cb) {\n            Y.log('Writing API Meta Data', 'info', 'builder');\n            var self = this;\n            this.renderAPIMeta(function (js) {\n                fs.writeFile(path.join(self.options.outdir, 'api.js'), js, Y.charset, cb);\n            });\n        },\n        /**\n         * Render the API meta and return the JavaScript\n         * @method renderAPIMeta\n         * @param {Callback} cb The callback\n         * @param {String} cb.apijs The JavaScript code to write API meta data\n         * @async\n         */\n        renderAPIMeta: function (cb) {\n\n            var opts = {\n                meta: {}\n            };\n            opts = this.populateClasses(opts);\n            opts = this.populateModules(opts);\n            opts = this.populateElements(opts);\n\n            ['classes', 'modules', 'elements'].forEach(function (id) {\n                opts.meta[id].forEach(function (v, k) {\n                    opts.meta[id][k] = v.name;\n                    if (v.submodules) {\n                        v.submodules.forEach(function (s) {\n                            opts.meta[id].push(s.displayName);\n                        });\n                    }\n                });\n                opts.meta[id].sort();\n            });\n\n            var apijs = 'YUI.add(\"yuidoc-meta\", function(Y) {\\n' +\n                '   Y.YUIDoc = { meta: ' + JSON.stringify(opts.meta, null, 4) + ' };\\n' +\n                '});';\n\n            cb(apijs);\n        },\n        /**\n         * Normalizes a file path to a writable filename:\n         *\n         *    var path = 'lib/file.js';\n         *    returns 'lib_file.js';\n         *\n         * @method filterFileName\n         * @param {String} f The filename to normalize\n         * @return {String} The filtered file path\n         */\n        filterFileName: function (f) {\n            return f.replace(/[\\/\\\\]/g, '_');\n        },\n        /**\n         * Compiles the templates from the meta-data provided by DocParser\n         * @method compile\n         * @param {Callback} cb The callback to execute after it's completed\n         */\n        compile: function (cb) {\n            var self = this;\n            var starttime = (new Date()).getTime();\n            Y.log('Compiling Templates', 'info', 'builder');\n\n            this.mixExternal(function () {\n                self.makeDirs(function () {\n                    Y.log('Copying Assets', 'info', 'builder');\n                    if (!Y.Files.isDirectory(path.join(self.options.outdir, 'assets'))) {\n                        fs.mkdirSync(path.join(self.options.outdir, 'assets'), '0777');\n                    }\n                    Y.Files.copyAssets([\n                            path.join(DEFAULT_THEME, 'assets'),\n                            path.join(themeDir, 'assets')\n                        ],\n                        path.join(self.options.outdir, 'assets'),\n                        false,\n                        function () {\n                            var cstack = new Y.Parallel();\n\n                            self.writeModules(cstack.add(function () {\n                                self.writeComponents('classes', cstack.add(function () {\n                                    if (!self.options.nocode) {\n                                        self.writeFiles(cstack.add(noop));\n                                    }\n                                }));\n                                self.writeComponents('elements', cstack.add(function () {\n                                    if (!self.options.nocode) {\n                                        self.writeFiles(cstack.add(noop));\n                                    }\n                                }));\n                            }));\n                            /*\n                        self.writeModules(cstack.add(noop));\n                        self.writeClasses(cstack.add(noop));\n                        if (!self.options.nocode) {\n                            self.writeFiles(cstack.add(noop));\n                        }\n                        */\n                            self.writeIndex(cstack.add(noop));\n                            self.writeAPIMeta(cstack.add(noop));\n\n                            cstack.done(function () {\n                                var endtime = (new Date()).getTime();\n                                var timer = ((endtime - starttime) / 1000) + ' seconds';\n                                Y.log('Finished writing ' + self.files + ' files in ' + timer, 'info', 'builder');\n                                if (cb) {\n                                    cb();\n                                }\n                            });\n                        });\n                });\n            });\n        }\n    };\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/docparser.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nYUI.add('docparser', function (Y) {\n\n    var Lang = Y.Lang,\n        trim = Lang.trim,\n        fixType = Y.Lang.fixType,\n        /**\n         * Parses the JSON data and formats it into a nice log string for\n         * filename and line number: `/file/name.js:123`\n         * @method stringlog\n         * @private\n         * @param {Object} data The data block from the parser\n         * @return {String} The formatted string.\n         * @for DocParser\n         */\n        stringlog = function (data) {\n            var line, file;\n\n            if (data.file && data.line) {\n                file = data.file;\n                line = data.line;\n            } else {\n                data.forEach(function (d) {\n                    if (d.tag === 'file') {\n                        file = d.value;\n                    }\n                    if (d.tag === 'line') {\n                        line = d.value;\n                    }\n                });\n            }\n            return ' ' + file + ':' + line;\n        },\n        /**\n         * Flatten a string, remove all line breaks and replace them with a token\n         * @method implodeString\n         * @private\n         * @param {String} str The string to operate on\n         * @return {String} The modified string\n         */\n        implodeString = function (str) {\n            return str.replace(REGEX_GLOBAL_LINES, '!~YUIDOC_LINE~!');\n        },\n        /**\n         * Un-flatten a string, replace tokens injected with `implodeString`\n         * @method implodeString\n         * @private\n         * @param {String} str The string to operate on\n         * @return {String} The modified string\n         */\n        explodeString = function (str) {\n            return str.replace(/!~YUIDOC_LINE~!/g, '\\n');\n        },\n        CURRENT_NAMESPACE = 'currentnamespace',\n        CURRENT_MODULE = 'currentmodule',\n        MAIN_MODULE = 'mainmodule',\n        CURRENT_SUBMODULE = 'currentsubmodule',\n        CURRENT_FILE = 'currentfile',\n        CURRENT_CLASS = 'currentclass',\n        CURRENT_ELEMENT = 'currentelement',\n\n        REGEX_TYPE = /(.*?)\\{(.*?)\\}(.*)/,\n        REGEX_FIRSTWORD = /^\\s*?(\\[.+\\]\\*?|[^\\s]+)(.*)/,\n        REGEX_OPTIONAL = /^\\[(.*)\\]$/,\n        REGEX_START_COMMENT = {\n            js: /^\\s*\\/\\*\\*/,\n            coffee: /^\\s*###\\*/\n        },\n        REGEX_END_COMMENT = {\n            js: /\\*\\/\\s*$/,\n            coffee: /###\\s*$/\n        },\n        REGEX_LINE_HEAD_CHAR = {\n            js: /^\\s*\\*/,\n            coffee: /^\\s*[#\\*]/\n        },\n        REGEX_LINES = /\\r\\n|\\n/,\n        REGEX_GLOBAL_LINES = /\\r\\n|\\n/g,\n\n        SHORT_TAGS = {\n            'async': 1,\n            'beta': 1,\n            'chainable': 1,\n            'extends': 1,\n            'final': 1,\n            'static': 1,\n            'optional': 1,\n            'required': 1\n        },\n\n        /**\n         * A list of known tags.  This populates a member variable\n         * during initialization, and will be updated if additional\n         * digesters are added.\n         * @property TAGLIST\n         * @type Array\n         * @final\n         * @for DocParser\n         */\n        TAGLIST = [\n            'async',        // bool, custom events can fire the listeners in a setTimeout\n            'author',       // author best for projects and modules, but can be used anywhere // multi\n            'attribute',    // YUI attributes / custom element attributes\n            'beta',         // module maturity identifier\n            'broadcast',    // bool, events\n            'bubbles',      // custom events that bubble\n            'category',     // modules can be in multiple categories\n            'chainable',    // methods that return the host object\n            'class',        // pseudo class\n            'conditional',  // conditional module\n            'config',       // a config param (not an attribute, so no change events)\n            'const',        // not standardized yet, converts to final property\n            'constructs',   // factory methods (not yet used)\n            'constructor',  // this is a constructor\n            'content',      // permitted content for an @element\n            'contributor',  // like author\n            'default',      // property/attribute default value\n            'deprecated',   // please specify what to use instead\n            'description',  // can also be free text at the beginning of a comment is\n            'emitfacade',   // bool, YUI custom event can have a dom-like event facade\n            'element',      // Web Components custom element\n            'event',        // YUI custom event\n            'evil',         // uses eval\n            'extension',    // this is an extension for [entity]\n            'extensionfor', // this is an extension for [entity]\n            'extension_for',// this is an extension for [entity]\n            'example',      // 0..n code snippets.  snippets can also be embedded in the desc\n            'experimental', // module maturity identifier\n            'extends',      // pseudo inheritance\n            'file',         // file name (used by the parser)\n            'final',        // not meant to be changed\n            'fireonce',     // bool, YUI custom event config allows\n            'for',          // used to change class context\n            'global',       // declare your globals\n            'icon',         // project icon(s)\n            'implements',   // Implements Interface\n            'in',           // indicates module this lives in (obsolete now)\n            'initonly',     // attribute writeonce value\n            'injects',      // injects {HTML|script|CSS}\n            'interface',    // Is Interface / Interface for an @element\n            'knownissue',   // 0..n known issues for your consumption\n            'line',         // line number for the comment block (used by the parser)\n            'method',       // a method\n            'module',       // YUI module name\n            'main',         // Description for the module\n            'namespace',    // Y.namespace, used to fully qualify class names\n            'optional',     // For optional attributes\n            'required',     // For required attributes\n            'param',        // member param\n            'parents',      // permitted parents for an @element\n            'plugin',       // this is a plugin for [entityl]\n            'preventable',  // YUI custom events can be preventable ala DOM events\n            'private',      // > access\n            'project',      // project definition, one per source tree allowed\n            'property',     // a regular-ole property\n            'protected',    // > access\n            'public',       // > access\n            'queuable',     // bool, events\n            'readonly',     // YUI attribute config\n            'requires',     // YUI module requirements\n            'return',       // {type} return desc -- returns is converted to this\n            'see',          // 0..n things to look at\n            'since',        // when it was introduced\n            'static',       // static\n            'submodule',    // YUI submodule\n            'throws',       // {execption type} description\n            'title',        // this should be something for the project description\n            'todo',         // 0..n things to revisit eventually (hopefully)\n            'type',         // the var type\n            'url',          // project url(s)\n            'uses',         // 0..n compents mixed (usually, via augment) into the prototype\n            'value',        // the value of a constant\n            'writeonce'     // YUI attribute config\n        ],\n\n        /**\n         * A list of ignored tags. These tags should be ignored because there is\n         * likely to be used for purposes other than JSDoc tags in JavaScript comments.\n         * @property IGNORE_TAGLIST\n         * @type Array\n         * @final\n         * @for DocParser\n         */\n        IGNORE_TAGLIST = [\n            'media'\n        ],\n\n        /**\n         * Common errors will get scrubbed instead of being ignored.\n         * @property CORRECTIONS\n         * @type Object\n         * @final\n         * @for DocParser\n         */\n        CORRECTIONS = {\n            'augments': 'uses', // YUI convention for prototype mixins\n            'depreciated': 'deprecated', // subtle difference\n            'desciption': 'description', // shouldn't need the @description tag at all\n            'extend': 'extends', // typo\n            'function': 'method', // we may want standalone inner functions at some point\n            'member': 'method', // probably meant method\n            'parm': 'param', // typo\n            'params': 'param', // typo\n            'pamra': 'param', // typo\n            'parma': 'param', // typo\n            'propery': 'property', // typo\n            'prop': 'property', // probably meant property\n            'returns': 'return' // need to standardize on one or the other\n        },\n\n        /**\n         * A map of the default tag processors, keyed by the\n         * tag name.  Multiple tags can use the same digester\n         * by supplying the string name that points to the\n         * implementation rather than a function.\n         * @property DIGESTERS\n         * @type Object\n         * @final\n         * @for DocParser\n         */\n        DIGESTERS = {\n            // \"params\": [\n            // {\n            //   \"name\": \"optionalandmultiple\",\n            //   \"description\": \"my desc\",\n            //   \"type\": \"string\",\n            //   \"optional\": true, // [surroundedbybrackets]\n            //   \"optdefault\": \"if specified, this is always string to avoid syntax errors @TODO\",\n            //   \"multiple\": true // endswith* or ...startswith\n            // }\n            // ],\n            // @param {type} name description    -or-\n            // @param name {type} description\n            // #2173362 optional w/ or w/o default\n            // @param {type} [optvar=default] description\n            // #12 document config objects\n            // @param {object|config} config description\n            // @param {type} config.prop1 description\n            // @param {type} config.prop2 description\n            // #11 document callback argument signature\n            // @param {callback|function} callback description\n            // @param {type} callback.arg1 description\n            // @param {type} callback.arg2 description\n            // #2173362 document event facade decorations for custom events\n            // @param {event} event description\n            // @param {type}  event.child description\n            // @param {type}  event.index description\n            // @param name* {type} 1..n description\n            // @param [name]* {type} 0..n description\n            'param': function (tagname, value, target, block) {\n                // Y.log('param digester' + value);\n                target.params = target.params || [];\n\n                if (!value) {\n                    this.warnings.push({\n                        message: 'param name/type/descript missing',\n                        line: stringlog(block)\n                    });\n                    Y.log('param name/type/descript missing: ' + stringlog(block), 'warn', 'docparser');\n                    return;\n                }\n\n                var type, name, parts, optional, optdefault, parent, multiple, len, result,\n                    desc = implodeString(trim(value)),\n                    match = REGEX_TYPE.exec(desc),\n                    host = target.params;\n\n                // Extract {type}\n                if (match) {\n                    type = fixType(trim(match[2]));\n                    desc = trim(match[1] + match[3]);\n                }\n\n                // extract the first word, this is the param name\n                match = REGEX_FIRSTWORD.exec(desc);\n                if (match) {\n                    name = trim(explodeString(match[1]));\n                    desc = trim(match[2]);\n                }\n\n                if (!name) {\n                    if (value && value.match(/callback/i)) {\n                        this.warnings.push({\n                            message: 'Fixing missing name for callback',\n                            line: stringlog(block)\n                        });\n                        Y.log('Fixing missing name for callback:' + stringlog(block), 'warn', 'docparser');\n                        name = 'callback';\n                        type = 'Callback';\n                    } else {\n                        this.warnings.push({\n                            message: 'param name missing: ' + value,\n                            line: stringlog(block)\n                        });\n                        Y.log('param name missing: ' + value + ':' + stringlog(block), 'warn', 'docparser');\n                        name = 'UNKNOWN';\n                    }\n                }\n\n                len = name.length - 1;\n\n                if (name.charAt(len) === '*') {\n                    multiple = true;\n                    name = name.substr(0, len);\n                }\n\n                // extract [name], optional param\n                if (name.indexOf('[') > -1) {\n                    match = REGEX_OPTIONAL.exec(name);\n                    if (match) {\n                        optional = true;\n                        name = trim(match[1]);\n                        // extract optional=defaultvalue\n                        parts = name.split('=');\n                        if (parts.length > 1) {\n                            name = parts[0];\n                            optdefault = parts[1];\n                            //Add some shortcuts for object/array defaults\n                            if (optdefault.toLowerCase() === 'object') {\n                                optdefault = '{}';\n                            }\n                            if (optdefault.toLowerCase() === 'array') {\n                                optdefault = '[]';\n                            }\n                        }\n                    }\n                }\n\n                // This should run after the check for optional parameters\n                // and before the check for child parameters\n                // because the signature for 0..n params is [...args]\n                if (name.substr(0, 3) === '...') {\n                    multiple = true;\n                    name = name.substr(3);\n                }\n\n                // parse object.prop, indicating a child property for object\n                if (name.indexOf('.') > -1) {\n                    match = name.split('.');\n                    parent = trim(match[0]);\n                    Y.each(target.params, function (param) {\n                        if (param.name === parent) {\n                            param.props = param.props || [];\n                            host = param.props;\n                            match.shift();\n                            name = trim(match.join('.'));\n                            if (match.length > 1) {\n                                var pname = name.split('.')[0],\n                                    par;\n                                Y.each(param.props, function (o) {\n                                    if (o.name === pname) {\n                                        par = o;\n                                    }\n                                });\n                                if (par) {\n                                    match = name.split('.');\n                                    match.shift();\n                                    name = match.join('.');\n                                    par.props = par.props || [];\n                                    host = par.props;\n                                }\n                            }\n                        }\n                    });\n\n                }\n\n                result = {\n                    name: name,\n                    description: explodeString(desc)\n                };\n\n                if (type) {\n                    result.type = type;\n                }\n\n                if (optional) {\n                    result.optional = true;\n                    if (optdefault) {\n                        result.optdefault = optdefault;\n                    }\n                }\n\n                if (multiple) {\n                    result.multiple = true;\n                }\n\n                host.push(result);\n            },\n\n            // @return {type} description // methods\n            // @returns {type} description // methods\n            // @injects {HTML|CSS|script} description\n            // can be used by anthing that has an optional {type} and a description\n            'return': function (tagname, value, target) {\n\n                var desc = implodeString(trim(value)),\n                    type,\n                    match = REGEX_TYPE.exec(desc),\n                    result = {};\n                if (match) {\n                    type = fixType(trim(match[2]));\n                    desc = trim(match[1] + match[3]);\n                }\n\n                result = {\n                    description: Y.unindent(explodeString(desc))\n                };\n\n                if (type) {\n                    result.type = type;\n                }\n\n                target[tagname] = result;\n\n            },\n\n            // @throws {type} description\n            'throws': 'return',\n\n            'injects': 'return',\n\n            // trying to overwrite the constructor value is a bad idea\n            'constructor': function (tagname, value, target) {\n                target.is_constructor = 1;\n            },\n\n            // @author {twitter: @arthurdent | github: ArthurDent}\n            //    Arthur Dent adent@h2g2.earth #23, multiple // modules/class/method\n            // 'author': function(tagname, value, target, block) {\n            //     // Y.log('author digester');\n            // },\n\n            // A key bock type for declaring modules and submodules\n            // subsequent class and member blocks will be assigned\n            // to this module.\n            'module': function (tagname, value, target, block) {\n                this.set(CURRENT_MODULE, value);\n                var go = true;\n                Y.some(block, function (o) {\n                    if (trim(o.tag) === 'submodule') {\n                        go = false;\n                        return true;\n                    }\n                });\n                if (go) {\n                    if (!this.get(MAIN_MODULE)) {\n                        this.set(MAIN_MODULE, {\n                            tag: tagname,\n                            name: value,\n                            file: target.file,\n                            line: target.line,\n                            description: target.description\n                        });\n                    }\n                    return this.modules[value];\n                }\n                return null;\n            },\n\n            //Setting the description for the module..\n            'main': function (tagname, value, target) {\n                var o = target;\n                o.mainName = value;\n                o.tag = tagname;\n                o.itemtype = 'main';\n                o._main = true;\n                this.set(MAIN_MODULE, o);\n            },\n\n            // accepts a single project definition for the source tree\n            'project': function () {\n                return this.project;\n            },\n\n            // A key bock type for declaring submodules.  subsequent class and\n            // member blocks will be assigned to this submodule.\n            'submodule': function (tagname, value) {\n                //console.log('Setting current submodule: ', value, 'on class');\n                this.set(CURRENT_SUBMODULE, value);\n                var host = this.modules[value],\n                    clazz = this.get(CURRENT_CLASS),\n                    parent = this.get(CURRENT_MODULE);\n                if (parent) {\n                    host.module = parent;\n                }\n                if (clazz && this.classes[clazz]) {\n                    //console.log('Adding submodule', value , 'to class', clazz, ' it has submodule', this.classes[clazz].submodule);\n                    //if (!this.classes[clazz].submodule) {\n                    //console.log('REALLY Adding submodule', value , 'to class', clazz);\n                    this.classes[clazz].submodule = value;\n                    //}\n                }\n                return host;\n            },\n\n            // A key bock type for declaring classes, subsequent\n            // member blocks will be assigned to this class\n            'class': function (tagname, value, target, block) {\n                var namespace, fullname, host, parent;\n\n                block.forEach(function (def) {\n                    if (def.tag === 'namespace') {\n                        //We have a namespace, augment the name\n                        var name = trim(def.value) + '.' + value;\n                        if (value.indexOf(trim(def.value) + '.') === -1) {\n                            value = name;\n                            namespace = trim(def.value);\n                        }\n                    }\n                });\n\n                if (namespace) {\n                    this.set(CURRENT_NAMESPACE, namespace);\n                }\n                this.set(CURRENT_CLASS, value);\n\n                fullname = this.get(CURRENT_CLASS);\n                host = this.classes[fullname];\n                parent = this.get(CURRENT_MODULE);\n\n                if (namespace) {\n                    host.namespace = namespace;\n                }\n                if (parent) {\n                    host.module = parent;\n                }\n\n                //Merge host and target in case the class was defined in a \"for\" tag\n                //before it was defined in a \"class\" tag\n                host = Y.merge(host, target);\n                this.classes[fullname] = host;\n                parent = this.get(CURRENT_SUBMODULE);\n                if (parent) {\n                    //this.set(CURRENT_SUBMODULE, parent);\n                    host.submodule = parent;\n                }\n                return host;\n            },\n\n            // A key bock type for declaring custom elements\n            'element': function (tagname, value) {\n                var name, parent, host;\n\n                name = value.split(/\\s+/)[0];\n                this.set(CURRENT_ELEMENT, name);\n                host = this.elements[name];\n\n                parent = this.get(CURRENT_MODULE);\n                if (parent) {\n                    host.module = parent;\n                }\n\n                parent = this.get(CURRENT_SUBMODULE);\n                if (parent) {\n                    host.submodule = parent;\n                }\n\n                return host;\n            },\n\n            // change 'const' to final property\n            'const': function (tagname, value, target) {\n                target.itemtype = 'property';\n                target.name = value;\n                target.final = '';\n            },\n\n            // supported classitems\n            'property': function (tagname, value, target, block) {\n                var match, name, desc, type;\n\n                target.itemtype = tagname;\n                target.name = value;\n                if (!target.type) {\n                    desc = implodeString(trim(value));\n                    match = REGEX_TYPE.exec(desc);\n\n                    // Extract {type}\n                    if (match) {\n                        type = fixType(trim(match[2]));\n                        name = trim(match[1] + match[3]);\n                        target.type = type;\n                        target.name = name;\n                    }\n\n                }\n                if (target.type && target.type.toLowerCase() === 'object') {\n                    block.forEach(function (i, k) {\n                        if (i.tag === 'property') {\n                            i.value = trim(i.value);\n                            i.tag = 'param';\n                            block[k] = i;\n                        }\n                    });\n                }\n            },\n            'method': 'property',\n            'config': 'property',\n            'event': 'property',\n\n            'attribute': function (tagname, value, target) {\n                // Use 'property' if not currently parsing an element\n                if (!this.get(CURRENT_ELEMENT)) {\n                    return DIGESTERS.property.apply(this, arguments);\n                }\n\n                var nameVal = value.split(/\\s+([\\s\\S]*$)/),\n                    desc = nameVal[1] || target.description || '';\n\n                if (!target.attributes) {\n                    target.attributes = [];\n                }\n                target.attributes.push({\n                    name: nameVal[0],\n                    description: desc\n                });\n            },\n\n            // access fields\n            'public': function (tagname, value, target) {\n                target.access = tagname;\n                target.tagname = value;\n            },\n            'private': 'public',\n            'protected': 'public',\n            'inner': 'public',\n\n            // tags that can have multiple occurances in a single block\n            'todo': function (tagname, value, target) {\n                if (!Lang.isArray(target[tagname])) {\n                    target[tagname] = [];\n                }\n                //If the item is @tag one,two\n                if (value.indexOf(',') > -1) {\n                    value = value.split(',');\n                } else {\n                    value = [value];\n                }\n\n                value.forEach(function (v) {\n                    v = trim(v);\n                    target[tagname].push(v);\n                });\n            },\n            'extension_for': 'extensionfor',\n            'extensionfor': function (tagname, value) {\n                if (this.classes[this.get(CURRENT_CLASS)]) {\n                    this.classes[this.get(CURRENT_CLASS)].extension_for.push(value);\n                }\n            },\n            'example': function (tagname, value, target, block) {\n                if (!Lang.isArray(target[tagname])) {\n                    target[tagname] = [];\n                }\n\n                var e = value;\n                block.forEach(function (v) {\n                    if (v.tag === 'example') {\n                        if (v.value.indexOf(value) > -1) {\n                            e = v.value;\n                        }\n                    }\n                });\n\n                target[tagname].push(e);\n            },\n            'url': 'todo',\n            'icon': 'todo',\n            'see': 'todo',\n            'requires': 'todo',\n            'knownissue': 'todo',\n            'uses': 'todo',\n            'category': 'todo',\n            'unimplemented': 'todo',\n\n            genericValueTag: function (tagname, value, target) {\n                target[tagname] = value;\n            },\n\n            'author': 'genericValueTag',\n            'contributor': 'genericValueTag',\n            'since': 'genericValueTag',\n\n            'deprecated': function (tagname, value, target) {\n                target.deprecated = true;\n\n                if (typeof value === 'string' && value.length) {\n                    target.deprecationMessage = value;\n                }\n            },\n\n            // updates the current namespace\n            'namespace': function (tagname, value) {\n                this.set(CURRENT_NAMESPACE, value);\n                if (value === '') {\n                    //Shortcut this if namespace is an empty string.\n                    return;\n                }\n                var m,\n                    mod,\n                    name,\n                    lastNS,\n                    file = this.get(CURRENT_FILE);\n                if (file) {\n                    this.files[file].namespaces[value] = 1;\n                }\n                mod = this.get(CURRENT_MODULE);\n                if (mod) {\n                    this.modules[mod].namespaces[value] = 1;\n                }\n\n                mod = this.get(CURRENT_SUBMODULE);\n                if (mod) {\n                    this.modules[mod].namespaces[value] = 1;\n                }\n\n                mod = this.get(CURRENT_CLASS);\n                if (mod) {\n                    lastNS = this.get('lastnamespace');\n                    if (lastNS && lastNS !== value && (value.indexOf(lastNS + '.') !== 0)) {\n                        if (this.classes[mod]) {\n                            m = this.classes[mod];\n                            delete this.classes[mod];\n                            mod = value + '.' + mod.replace(lastNS + '.', '');\n                            m.name = mod;\n                            m.namespace = value;\n                            this.classes[mod] = m;\n                            this.set(CURRENT_CLASS, m.name);\n                        }\n                    }\n                    if (this.classes[mod]) {\n                        this.classes[mod].namespace = value;\n                        if (mod === value) {\n                            return;\n                        }\n                        if (mod.indexOf(value + '.') === -1) {\n                            if (mod.indexOf('.') === -1) {\n                                m = this.classes[mod];\n                                delete this.classes[mod];\n                                name = m.namespace + '.' + m.name;\n                                m.name = name;\n                                this.classes[name] = m;\n                                this.set(CURRENT_CLASS, name);\n                            } else {\n                                if (mod.indexOf(this.classes[mod].namespace + '.') === -1) {\n                                    m = this.classes[mod];\n                                    delete this.classes[mod];\n                                    name = m.namespace + '.' + m.shortname;\n                                    m.name = name;\n                                    this.classes[name] = m;\n                                    this.set(CURRENT_CLASS, name);\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n\n            // updates the current class only (doesn't create\n            // a new class definition)\n            'for': function (tagname, value) {\n                var ns, file, mod;\n\n                value = this._resolveFor(value);\n                this.set(CURRENT_CLASS, value);\n\n                ns = ((this.classes[value]) ? this.classes[value].namespace : '');\n                this.set(CURRENT_NAMESPACE, ns);\n\n                file = this.get(CURRENT_FILE);\n                if (file) {\n                    this.files[file].fors[value] = 1;\n                }\n\n                mod = this.get(CURRENT_MODULE);\n                if (mod) {\n                    this.modules[mod].fors[value] = 1;\n                }\n\n                mod = this.get(CURRENT_SUBMODULE);\n                if (mod) {\n                    this.modules[mod].fors[value] = 1;\n                }\n            }\n        },\n\n        /**\n         * The doc parser accepts a **map** of files to file content.\n         * Once `parse()` is called, various properties will be populated\n         * with the parsers data (aggregated in the `'data'` property).\n         * @class DocParser\n         * @extends Base\n         * @constructor\n         * @param {Object} o the config object\n         * @module yuidoc\n         */\n        DocParser = function () {\n            this.digesters = Y.merge(DocParser.DIGESTERS);\n            this.knowntags = Y.Array.hash(DocParser.TAGLIST);\n            DocParser.superclass.constructor.apply(this, arguments);\n        };\n\n    DocParser.NAME = 'DocParser';\n\n    DocParser.DIGESTERS = DIGESTERS;\n    DocParser.TAGLIST = TAGLIST;\n    DocParser.CORRECTIONS = CORRECTIONS;\n\n    DocParser.ATTRS = {\n\n        lint: {\n            value: false\n        },\n\n        /**\n         * Digesters process the tag/text pairs found in a\n         * comment block.  They are looked up by tag name.\n         * The digester gets the tagname, the value, the\n         * target object to apply values to, and the full\n         * block that is being processed.  Digesters can\n         * be declared as strings instead of a function --\n         * in that case, the program will try to look up\n         * the key listed and use the function there instead\n         * (it is an alias).  Digesters can return a host\n         * object in the case the tag defines a new key\n         * block type (modules/classes/methods/events/properties)\n         * @attribute digesters\n         */\n        digesters: {\n            setter: function (val) {\n                Y.mix(this.digesters, val, true);\n                Y.mix(this.knowntags, val, true);\n                return val;\n            }\n        },\n\n        /**\n         * Emitters will be schemas for the types of payloads\n         * the parser will emit.  Not implemented.\n         * @attribute emitters\n         */\n        emitters: {\n            setter: function (val) {\n                Y.mix(this.emitters, val, true);\n            }\n        },\n\n        /**\n         * Comment syntax type.\n         * @attribute syntaxtype\n         * @type String\n         */\n        syntaxtype: {\n            writeOnce: true\n        },\n\n        /**\n         * The map of file names to file content.\n         * @attribute filemap\n         */\n        filemap: {\n            writeOnce: true\n        },\n\n        /**\n         * A map of file names to directory name.  Provided in\n         * case this needs to be used to reset the module name\n         * appropriately -- currently not used\n         * @attribute dirmap\n         */\n        dirmap: {\n            writeOnce: true\n        },\n\n        /**\n         * The file currently being parsed\n         * @attribute currentfile\n         * @type String\n         */\n        currentfile: {\n            setter: function (val) {\n                val = trim(val);\n                // this.set(CURRENT_NAMESPACE, '');\n                if (!(val in this.files)) {\n                    this.files[val] = {\n                        name: val,\n                        modules: {},\n                        classes: {},\n                        fors: {},\n                        namespaces: {}\n                    };\n                }\n                return val;\n            }\n        },\n        /**\n         * The main documentation block for the module itself.\n         * @attribute mainmodule\n         * @type String\n         */\n        mainmodule: {\n            setter: function (o) {\n                if (!o) {\n                    return;\n                }\n                //console.log('Main Module Setter: ', o);\n                var write = true,\n                    name = o.mainName || o.name;\n                if (this.get(CURRENT_MODULE) === name) {\n\n                    if (name in this.modules) {\n                        //console.log('In Global Modules', this.modules[name]);\n                        if (this.modules[name].tag) {\n                            //The main module has already been added, don't over write it.\n                            if (this.modules[name].tag === 'main') {\n                                write = false;\n                            }\n                        }\n                        if (write) {\n                            //console.log('Writing');\n                            this.modules[name] = Y.merge(this.modules[name], o);\n                        }\n                    } else {\n                        if (o._main) {\n                            //console.log('Writing');\n                            this.modules[name] = o;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n         * The module currently being parsed\n         * @attribute currentmodule\n         * @type String\n         */\n        currentmodule: {\n            setter: function (val) {\n                if (!val) {\n                    return val;\n                }\n                val = trim(val);\n\n                var modMain, clazz;\n\n                this.set(CURRENT_SUBMODULE, '');\n                this.set(CURRENT_NAMESPACE, '');\n\n                modMain = this.get(MAIN_MODULE);\n                if (modMain && modMain.name !== val) {\n                    this.set(MAIN_MODULE, '');\n                }\n\n                clazz = this.classes[this.get(CURRENT_CLASS)];\n                if (clazz) {\n                    //Handles case where @module comes after @class in a new directory of files\n                    if (clazz.module !== val) {\n                        if (this.modules[clazz.module]) {\n                            delete this.modules[clazz.module].submodules[clazz.submodule];\n                            delete this.modules[clazz.module].classes[clazz.name];\n                        }\n                        if (clazz.submodule && this.modules[clazz.submodule]) {\n                            delete this.modules[clazz.submodule].submodules[clazz.submodule];\n                            delete this.modules[clazz.submodule].classes[clazz.name];\n                        }\n                        clazz.module = val;\n                        if (this.modules[val]) {\n                            this.modules[val].submodules[clazz.submodule] = 1;\n                            this.modules[val].classes[clazz.name] = 1;\n                        }\n                        if (clazz.submodule && this.modules[clazz.submodule]) {\n                            this.modules[clazz.submodule].module = val;\n                        }\n                    }\n                }\n\n                if (!(val in this.modules)) {\n                    this.modules[val] = {\n                        name: val,\n                        submodules: {},\n                        elements: {},\n                        classes: {},\n                        fors: {},\n                        namespaces: {}\n                    };\n                }\n\n                return val;\n            }\n        },\n\n        /**\n         * The submodule currently being parsed\n         * @attribute currentsubmodule\n         * @type String\n         */\n        currentsubmodule: {\n            setter: function (val) {\n                if (!val) {\n                    return val;\n                }\n                val = trim(val);\n                if (!(val in this.modules)) {\n                    var mod = this.modules[val] = {\n                        name: val,\n                        submodules: {},\n                        elements: {},\n                        classes: {},\n                        fors: {},\n                        is_submodule: 1,\n                        namespaces: {}\n                    };\n\n                    mod.module = this.get(CURRENT_MODULE);\n                    mod.namespace = this.get(CURRENT_NAMESPACE);\n                }\n                //console.log('SETTING CURRENT SUBMODULE: ', val, 'ON CLASS', this.get(CURRENT_CLASS));\n                return val;\n            }\n        },\n        currentnamespace: {\n            setter: function (val) {\n                this.set('lastnamespace', this.get(CURRENT_NAMESPACE));\n                return val;\n            }\n        },\n        lastnamespace: {\n\n        },\n        lastclass: {\n\n        },\n        /**\n         * The class currently being parsed\n         * @attribute currentclass\n         * @type String\n         */\n        currentclass: {\n            setter: function (val) {\n                if (!val) {\n                    return val;\n                }\n                this.set('lastclass', this.get(CURRENT_CLASS));\n                val = trim(val);\n                var name = val,\n                    ns, clazz;\n                if (!(val in this.classes)) {\n                    ns = this.get(CURRENT_NAMESPACE);\n                    if (ns && ns !== '' && (val.indexOf(ns + '.') !== 0)) {\n                        name = ns + '.' + val;\n                    }\n                    clazz = this.classes[name] = {\n                        name: name,\n                        shortname: val,\n                        classitems: [],\n                        plugins: [],\n                        extensions: [],\n                        plugin_for: [],\n                        extension_for: []\n                    };\n                    clazz.module = this.get(CURRENT_MODULE);\n                    if (this.get(CURRENT_SUBMODULE)) {\n                        clazz.submodule = this.get(CURRENT_SUBMODULE);\n                    }\n                    clazz.namespace = ns;\n                }\n                return name;\n            }\n        },\n        lastelement: {\n\n        },\n        /**\n         * The element currently being parsed\n         * @attribute currentelement\n         * @type String\n         */\n        currentelement: {\n            setter: function (val) {\n                if (!val) {\n                    return val;\n                }\n                this.set('lastelement', this.get(CURRENT_ELEMENT));\n                val = trim(val);\n                var name = val,\n                    el;\n                if (!(val in this.elements)) {\n                    el = this.elements[name] = {\n                        name: name,\n                        attributes: []\n                    };\n                    el.module = this.get(CURRENT_MODULE);\n                    if (this.get(CURRENT_SUBMODULE)) {\n                        el.submodule = this.get(CURRENT_SUBMODULE);\n                    }\n                }\n                return name;\n            }\n        }\n    };\n\n    Y.extend(DocParser, Y.Base, {\n        /**\n         * Takes a non-namespaced classname and resolves it to a namespace (to support `@for`)\n         * @private\n         * @method _resolveFor\n         * @param {String} value The classname to resolve\n         * @return {String} The resolved namespace + classname\n         */\n        _resolveFor: function (value) {\n            if (value.indexOf('.') === -1) {\n                Y.each(this.classes, function (i) {\n                    if (i.shortname === value) {\n                        if (i.namespace) {\n                            value = i.namespace + '.' + i.shortname;\n                        }\n                    }\n                });\n            }\n            return value;\n        },\n\n        initializer: function () {\n            this.warnings = [];\n\n            var self = this;\n            self.after('currentfileChange', function () {\n                /*\n                 * File changed, so we reset class and submodule.\n                 * You should use @for if you want to reference another class\n                 * in different file.\n                 */\n                self.set(CURRENT_SUBMODULE, '');\n                self.set(CURRENT_CLASS, '');\n                self.set(CURRENT_ELEMENT, '');\n            });\n\n            self.after('currentmoduleChange', function (e) {\n                var mod = e.newVal,\n                    elements = self.elements,\n                    classes = self.classes,\n                    addModule = function (c) {\n                        if (!(c.module)) {\n                            c.module = mod;\n                        }\n                    };\n\n                Y.each(classes, addModule);\n                Y.each(elements, addModule);\n            });\n\n            self.after('currentsubmoduleChange', function (e) {\n                var mod = e.newVal,\n                    classes = self.classes,\n                    elements = self.elements,\n                    addModule = function (c) {\n                        if (!(c.submodule)) {\n                            if (!c.module) {\n                                c.submodule = mod;\n                            }\n                        }\n                    };\n\n                if (mod) {\n                    Y.each(classes, addModule);\n                    Y.each(elements, addModule);\n                }\n            });\n\n            self.after('currentclassChange', function (e) {\n                var clazz = e.newVal;\n                Y.each(self.classitems, function (item) {\n                    if (!(item.class)) {\n                        item.class = clazz;\n                    }\n                });\n                // Y.log(self.classitems);\n            });\n        },\n\n        /**\n        Normalizes the initial indentation of the given _content_ so that the first line\n        is unindented, and all other lines are unindented to the same degree as the\n        first line. So if the first line has four spaces at the beginning, then all\n        lines will be unindented four spaces. Ported from [Selleck](https://github.com/rgrove/selleck)\n\n        @method unindent\n        @param {String} content Text to unindent.\n        @return {String} Unindented text.\n        @private\n        **/\n        unindent: function (content) {\n            var indent = content.match(/^(\\s+)/);\n\n            if (indent) {\n                content = content.replace(new RegExp('^' + indent[1], 'gm'), '');\n            }\n\n            return content;\n        },\n\n        /**\n        Transforms a JavaDoc style comment block (less the start and end of it)\n        into a list of tag/text pairs. The leading space and '*' are removed,\n        but the remaining whitespace is preserved so that the output should be\n        friendly for both markdown and html parsers.\n\n        @method handlecomment\n        @param {String} comment The comment to parse\n        @param {String} file The file it was parsed from\n        @param {String} line The line number it was found on\n        **/\n        handlecomment: function (comment, file, line) {\n            var lines = comment.split(REGEX_LINES),\n                len = lines.length,\n                i,\n                regex,\n                parts, part, peek, skip,\n                tag, value,\n                results = [{\n                    tag: 'file',\n                    value: file\n                }, {\n                    tag: 'line',\n                    value: line\n                }],\n                syntaxtype = this.get('syntaxtype'),\n                lineHeadCharRegex = REGEX_LINE_HEAD_CHAR[syntaxtype],\n                hasLineHeadChar = lines[0] && lineHeadCharRegex.test(lines[0]);\n\n            // trim leading line head char(star or harp) if there are any\n            if (hasLineHeadChar) {\n                for (i = 0; i < len; i++) {\n                    lines[i] = lines[i].replace(lineHeadCharRegex, '');\n                }\n            }\n\n            // reconsitute and tokenize the comment block\n            comment = this.unindent(lines.join('\\n'));\n            regex = new RegExp('(?:^|\\\\n)\\\\s*((?!@' + IGNORE_TAGLIST.join(')(?!@') + ')@\\\\w*)');\n            parts = comment.split(regex);\n            len = parts.length;\n            for (i = 0; i < len; i++) {\n                value = '';\n                part = parts[i];\n                if (part === '') {\n                    continue;\n                }\n                skip = false;\n\n                // the first token may be the description, otherwise it should be a tag\n                if (i === 0 && part.substr(0, 1) !== '@') {\n                    if (part) {\n                        tag = '@description';\n                        value = part;\n                    } else {\n                        skip = true;\n                    }\n                } else {\n                    tag = part;\n                    // lookahead for the tag value\n                    peek = parts[i + 1];\n                    if (peek) {\n                        value = peek;\n                        i++;\n                    }\n                }\n\n                if (!skip && tag) {\n                    results.push({\n                        tag: tag.substr(1).toLowerCase(),\n                        value: value\n                    });\n                }\n            }\n\n            return results;\n        },\n\n        /**\n         * Accepts a map of filenames to file content.  Returns\n         * a map of filenames to an array of API comment block\n         * text.  This expects the comment to start with / **\n         * on its own line, and end with * / on its own\n         * line.  Override this function to provide an\n         * alternative comment parser.\n         * @method extract\n         * @param {Object} filemap A map of filenames to file content\n         * @param {Array} dirmap A map of file names to directory name\n         * @return {Object} A map of filenames to an array of extracted\n         * comment text.\n         */\n        extract: function (filemap, dirmap) {\n            filemap = filemap || this.get('filemap');\n            dirmap = dirmap || this.get('dirmap');\n            var syntaxtype = this.get('syntaxtype'),\n                commentmap = {};\n            Y.each(filemap, function (code, filename) {\n\n                var commentlines, comment, line,\n                    lines = code.split(REGEX_LINES),\n                    len = lines.length,\n                    i, linenum;\n\n                for (i = 0; i < len; i++) {\n                    line = lines[i];\n                    if (REGEX_START_COMMENT[syntaxtype].test(line)) {\n                        commentlines = [];\n\n                        linenum = i + 1;\n\n                        while (i < len && (!REGEX_END_COMMENT[syntaxtype].test(line))) {\n                            commentlines.push(line);\n                            i++;\n                            line = lines[i];\n                        }\n\n                        // we can look ahead here if we need to guess the\n                        // name/type like we do in the python version.\n\n                        // remove /**\n                        commentlines.shift();\n                        comment = commentlines.join('\\n');\n                        commentmap[filename] = commentmap[filename] || [];\n                        commentmap[filename]\n                            .push(this.handlecomment(comment, filename, linenum));\n                    }\n                }\n            }, this);\n\n            this.commentmap = commentmap;\n            return commentmap;\n        },\n\n        /**\n         * Processes all the tags in a single comment block\n         * @method processblock\n         * @param {Array} an array of the tag/text pairs\n         */\n        processblock: function (block) {\n            var target = {},\n                digestname,\n                digester,\n                host;\n\n            // Y.log(block);\n            Y.each(block, function (tag) {\n                var name = trim(tag.tag),\n                    value = trim(tag.value),\n                    ret;\n\n                //Convert empty values to a 1 for JSON data parsing later\n                if (SHORT_TAGS[name] && value === '') {\n                    value = 1;\n                }\n\n                if (tag && tag.tag) {\n                    if (!(name in this.knowntags)) {\n                        if (name in CORRECTIONS) {\n                            this.warnings.push({\n                                message: 'replacing incorrect tag: ' + name + ' with ' + CORRECTIONS[name],\n                                line: stringlog(block)\n                            });\n                            Y.log('replacing incorrect tag: ' + name + ' with ' + CORRECTIONS[name] + ': ' + stringlog(block), 'warn', 'docparser');\n                            name = CORRECTIONS[name];\n                        } else {\n                            this.warnings.push({\n                                message: 'unknown tag: ' + name,\n                                line: stringlog(block)\n                            });\n                            Y.log('unknown tag: ' + name + ',' + stringlog(block), 'warn', 'docparser');\n                        }\n                    }\n\n                    digestname = name;\n                    if (digestname in this.digesters) {\n                        digester = this.digesters[digestname];\n                        if (Lang.isString(digester)) {\n                            digester = this.digesters[digester];\n                        }\n                        ret = digester.call(this, name, value, target, block);\n                        host = host || ret;\n                    } else {\n                        target[name] = value;\n                    }\n                }\n            }, this);\n\n            if (host) {\n                Y.mix(host, target);\n\n                if (host.attributes && target.attributes) {\n                    host.attributes.push.apply(host.attributes, target.attributes);\n                }\n            } else if (target.attributes) {\n                host = this.elements[this.get(CURRENT_ELEMENT)];\n                if (host) {\n                    if (target.deprecated) {\n                        target.attributes.forEach(function (a) {\n                            a.deprecated = target.deprecated;\n\n                            if (target.deprecationMessage) {\n                                a.deprecationMessage = target.deprecationMessage;\n                            }\n                        });\n                    }\n                    host.attributes.push.apply(host.attributes, target.attributes);\n                }\n            } else {\n                this.classitems.push(target);\n                target.class = this.get(CURRENT_CLASS);\n                target.module = this.get(CURRENT_MODULE);\n\n                host = this.get(CURRENT_SUBMODULE);\n                if (host) {\n                    target.submodule = host;\n                }\n\n                host = this.get(CURRENT_NAMESPACE);\n                if (host) {\n                    target.namespace = host;\n                }\n            }\n        },\n\n        /**\n         * Transforms a map of filenames to arrays of comment blocks into a\n         * JSON structure that represents the entire processed API doc info\n         * and relationships between elements for the entire project.\n         * @method transform\n         * @param {object} commentmap The hash of files and parsed comment blocks\n         * @return {object} The transformed data for the project\n         */\n        transform: function (commentmap) {\n            var self = this,\n                project = self.project = {},\n                files = self.files = {},\n                modules = self.modules = {},\n                classes = self.classes = {},\n                elements = self.elements = {},\n                classitems = self.classitems = [];\n\n            self.data = {\n                project: project,\n                files: files,\n                modules: modules,\n                classes: classes,\n                elements: elements,\n                classitems: classitems\n            };\n\n            commentmap = commentmap || self.commentmap;\n\n            // process\n            Y.each(commentmap, function (blocks, file) {\n                //Y.log('transform: ' + file, 'info', 'docparser');\n                self.set(CURRENT_FILE, file);\n                Y.each(blocks, function (block) {\n                    self.processblock(block);\n                });\n            });\n\n            // cross reference\n            Y.each(modules, function (module, name) {\n                if (module.file) {\n                    files[module.file].modules[name] = 1;\n                }\n                if (module.is_submodule) {\n                    modules[module.module].submodules[name] = 1;\n                }\n                //Clean up processors\n                delete module.mainName;\n                delete module._main;\n            });\n\n            Y.each(classes, function (clazz, name) {\n                if (clazz.module) {\n                    modules[clazz.module].classes[name] = 1;\n                }\n                //console.error('------------------------------');\n                //console.error(clazz);\n                //console.error(modules[clazz.submodule]);\n                //console.error('------------------------------');\n                if (clazz.submodule) {\n                    modules[clazz.submodule].classes[name] = 1;\n                    if (!modules[clazz.submodule].description) {\n                        modules[clazz.submodule].description = clazz.description;\n                    }\n                }\n\n                if (clazz.file) {\n                    files[clazz.file].classes[name] = 1;\n                    if (modules[clazz.module]) {\n                        modules[clazz.module].file = clazz.file;\n                        modules[clazz.module].line = clazz.line;\n                    }\n                    if (modules[clazz.submodule]) {\n                        modules[clazz.submodule].file = clazz.file;\n                        modules[clazz.submodule].line = clazz.line;\n                    }\n                }\n                if (clazz.uses && clazz.uses.length) {\n                    clazz.uses.forEach(function (u) {\n                        var c = classes[u];\n                        if (c) {\n                            c.extension_for.push(clazz.name);\n                        }\n                    });\n                }\n            });\n\n            Y.each(elements, function (el, name) {\n                if (el.module) {\n                    modules[el.module].elements[name] = 1;\n                }\n\n                if (el.submodule) {\n                    modules[el.submodule].elements[name] = 1;\n                    if (!modules[el.submodule].description) {\n                        modules[el.submodule].description = el.description;\n                    }\n                }\n            });\n\n            Y.each(classitems, function (v) {\n                if (!v.itemtype) {\n                    self.warnings.push({\n                        message: 'Missing item type' + (v.description ? '\\n' + v.description : ''),\n                        line: stringlog(v)\n                    });\n                    Y.log('Missing item type: ' + stringlog(v), 'warn', 'DocParser');\n                    if (v.description) {\n                        Y.log('\\t\\t' + v.description, 'warn', 'DocParser');\n                    }\n                }\n                if (v.itemtype === 'property' && v.params) {\n                    v.subprops = v.params;\n                    v.subprops.forEach(function (i) {\n                        //Remove top level prop name from sub props (should have been done in the @param parser\n                        i.name = i.name.replace(v.name + '.', '');\n                    });\n                    delete v.params;\n                }\n            });\n\n            Y.each(modules, function (mod) {\n                if (!mod.file || !mod.line || !mod.name) {\n                    console.log('Failed to find lines for', mod);\n                }\n            });\n\n            return self;\n        },\n\n        /**\n         * Extracts and transforms the filemap provided to constructor\n         * @method parse\n         * @param {Array} filemap A map of filenames to file content\n         * @param {Array} dirmap A map of file names to directory name\n         * @return {DocParser} this parser instance.  The total results\n         * are available in parser.data.\n         */\n        parse: function (filemap, dirmap) {\n            filemap = filemap || this.get('filemap');\n            dirmap = dirmap || this.get('dirmap');\n            return this.transform(this.extract(filemap, dirmap));\n        }\n    });\n\n    Y.DocParser = DocParser;\n\n}, '0.1.0', {\n    requires: ['base-base']\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/docview.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nYUI.add('docview', function (Y) {\n\n    /*\n    Selleck\n    Copyright (c) 2011 Yahoo! Inc.\n    Licensed under the BSD License.\n    */\n\n    /**\n    View class borrowed from [Selleck](https://github.com/rgrove/selleck)\n    The view class is a **`handlebars`** template helper.\n    @class DocView\n    @constructor\n    @param {Object} data Meta data to use in this template\n    @param {String} templateName The name of the template file to render.\n    **/\n    function DocView(data, templateName) {\n        this.templateName = templateName;\n        Y.mix(this, data);\n    }\n\n    DocView.prototype = {\n        /**\n         * **Mustache** `lambda` method for setting the HTML title\n         * @method htmlTitle\n         */\n        htmlTitle: function () {\n            var name = this.displayName || this.name,\n                title = name;\n\n            if (title) {\n                if (this.projectName) {\n                    title += ' - ' + this.projectName;\n                }\n            } else {\n                title = this.projectName;\n            }\n\n            return title;\n        },\n\n        /**\n         * **Mustache** `lambda` method for setting the title\n         * @method title\n         */\n        title: function () {\n            var name = this.displayName || this.name,\n                title = this.projectName;\n\n            if (name) {\n                title += ': ' + name;\n            }\n\n            return title;\n        }\n    };\n\n    Y.DocView = DocView;\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/files.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nYUI.add('files', function (Y) {\n\n    /**\n     * Ported fileutils methods from [Selleck](http://github.com/rgrove/selleck)\n     * @class Files\n     * @module yuidoc\n     */\n\n    Y.Files = {};\n\n    /*\n    Selleck\n    Copyright (c) 2011 Yahoo! Inc.\n    Licensed under the BSD License.\n    */\n\n    var fs = require('graceful-fs');\n    var fsPath = require('path');\n    var useFS = (fs.exists) ? fs : fsPath;\n\n\n    function exists(file, cb) {\n        if (cb) {\n            useFS.exists(file, cb);\n        } else {\n            return useFS.existsSync(file);\n        }\n    }\n    Y.Files.exists = exists;\n\n\n    /**\n    Copy a directory from one location to another\n    @method copyDirectory\n    @param {Path} source The source directory\n    @param {Path} dest The destination directory\n    @param {Boolean} [overwrite=false] Whether or not to overwrite destination files\n        if they already exist.\n    @param {Function} callback The callback to be executed when complete.\n    **/\n    function copyDirectory(source, dest, overwrite, callback) {\n        // Allow callback as third arg.\n        if (typeof overwrite === 'function') {\n            callback = overwrite;\n            overwrite = null;\n        }\n\n        fs.stat(source, afterSourceStat);\n\n        function afterSourceStat(err, stats) {\n            if (err) {\n                return callback(err);\n            }\n\n            if (!stats.isDirectory()) {\n                return callback(new Error('Source is not a directory: ' + source));\n            }\n\n            fs.lstat(dest, afterDestStat);\n        }\n\n        function afterDestStat(err, stats) {\n            if (err && err.code !== 'ENOENT') {\n                return callback(err);\n            }\n\n            if (stats) {\n                // If the destination is a file or a link, either delete it or\n                // bubble an error if overwrite isn't true.\n                if (stats.isFile() || stats.isSymbolicLink()) {\n                    if (overwrite) {\n                        deletePath(dest); // TODO: make this async\n                    } else {\n                        callback(new Error('Destination already exists: ' + dest));\n                        return undefined;\n                    }\n                }\n\n                afterMkDir();\n            } else {\n                fs.mkdir(dest, '0755', afterMkDir);\n            }\n        }\n\n        function afterMkDir(err) {\n            if (err && err.code !== 'EEXIST') {\n                return callback(err);\n            }\n            fs.readdir(source, afterReadDir);\n        }\n\n        function afterReadDir(err, files) {\n            if (err) {\n                return callback(err);\n            }\n\n            var pending = files.length,\n                filename;\n\n            if (!pending) {\n                return callback();\n            }\n\n            while ((filename = files.shift())) {\n                copyPath(fsPath.join(source, filename), fsPath.join(dest, filename), overwrite, function (copyPathErr) {\n                    if (copyPathErr) {\n                        return callback(copyPathErr);\n                    }\n\n                    pending -= 1;\n\n                    if (!pending) {\n                        callback();\n                    }\n                });\n            }\n        }\n    }\n    Y.Files.copyDirectory = copyDirectory;\n\n    /**\n    Copy a file from one location to another\n    @method copyFile\n    @param {Path} source The source file\n    @param {Path} dest The destination file\n    @param {Boolean} [overwrite=false] Whether or not to overwrite destination files\n        if they already exist.\n    @param {Callback} callback The callback to be executed when complete.\n    @param {Error} callback.err The Error returned from Node\n    **/\n    function copyFile(source, dest, overwrite, callback) {\n        // Allow callback as third arg.\n        if (typeof overwrite === 'function') {\n            callback = overwrite;\n            overwrite = null;\n        }\n\n        fs.lstat(source, function (err, sourceStats) {\n            if (err) {\n                return callback(err);\n            }\n\n            if (!sourceStats.isFile()) {\n                return callback(new Error('Source is not a file: ' + source));\n            }\n\n            fs.lstat(dest, function (destStatsErr, destStats) {\n                var rs;\n\n                if (destStatsErr && destStatsErr.code !== 'ENOENT') {\n                    return callback(destStatsErr);\n                }\n\n                if (destStats) {\n                    if (overwrite) {\n                        deletePath(dest); // TODO: make this async\n                    } else {\n                        callback(new Error('Destination already exists: ' + dest));\n                        return undefined;\n                    }\n                }\n\n                rs = fs.createReadStream(source);\n                rs.pipe(fs.createWriteStream(dest, {\n                    mode: '0655'\n                }));\n                rs.on('end', callback);\n            });\n        });\n    }\n    Y.Files.copyFile = copyFile;\n\n\n    /**\n    If _source_ is a file, copies it to _dest_. If it's a directory, recursively\n    copies it and all files and directories it contains to _dest_.\n\n    Note that when attempting to copy a file into a directory, you should specify\n    the full path to the new file (including the new filename). Otherwise, it will\n    be interpreted as an attempt to copy the _source_ file *over* the _dest_\n    directory instead of *into* it.\n\n    Known issues:\n    - Doesn't preserve ownership or permissions on copied files/directories.\n\n    @method copyPath\n    @param {String} source Source path.\n    @param {String} dest Destination path.\n    @param {Boolean} [overwrite=false] Whether or not to overwrite destination files\n    if they already exist.\n    @param {Callback} callback The callback to execute when completed.\n    @param {Error} callback.err\n    **/\n    function copyPath(source, dest, overwrite, callback) {\n        var sourceStats = statSync(source);\n\n        // Allow callback as third arg.\n        if (typeof overwrite === 'function') {\n            callback = overwrite;\n            overwrite = null;\n        }\n\n        if (!sourceStats) {\n            callback(new Error('Source not found: ' + source));\n            return;\n        }\n\n        if (sourceStats.isFile()) {\n            copyFile(source, dest, overwrite, callback);\n        } else if (sourceStats.isDirectory()) {\n            copyDirectory(source, dest, overwrite, callback);\n        } else {\n            callback(new Error('Source is neither a file nor a directory: ' + source));\n        }\n    }\n    Y.Files.copyPath = copyPath;\n\n    // TODO: copySymbolicLink()?\n\n    /**\n    If _path_ is a file, deletes it. If _path_ is a directory, recursively deletes\n    it and all files and directories it contains.\n\n    This method is synchronous.\n\n    @method deletePath\n    @param {String} path File or directory to delete.\n    **/\n    function deletePath(path) {\n        var stats = fs.lstatSync(path);\n\n        if (stats.isFile() || stats.isSymbolicLink()) {\n            fs.unlinkSync(path);\n        } else if (stats.isDirectory()) {\n            fs.readdirSync(path).forEach(function (filename) {\n                deletePath(fsPath.join(path, filename));\n            });\n\n            fs.rmdirSync(path);\n        }\n    }\n    Y.Files.deletePath = deletePath;\n\n\n    /**\n    Check to see if this is a directory\n\n    @method isDirectory\n    @param {Path} path The path to check\n    @param {Boolean} [link=false] Also validate a symlink\n    @return {Boolean} True if it is a directory\n    **/\n    function isDirectory(path, link) {\n        var stat,\n            result = false;\n\n        link = (link === false) ? false : true;\n\n        try {\n            stat = fs.lstatSync(path);\n            if (stat) {\n                if (stat.isSymbolicLink() && link) {\n                    stat = fs.statSync(path);\n                }\n                result = stat.isDirectory();\n            }\n        } catch (e) {\n            result = false;\n        }\n\n        return result;\n    }\n    Y.Files.isDirectory = isDirectory;\n\n\n    /**\n    Check to see if this is a File\n\n    @method isFile\n    @param {Path} path The path to check\n    @param {Boolean} [link=false] Also validate a symlink\n    @return {Boolean} True if it is a file\n    **/\n    function isFile(path, link) {\n        var stat,\n            result = false;\n\n        try {\n            stat = fs.lstatSync(path);\n            if (stat) {\n                if (stat.isSymbolicLink() && link) {\n                    stat = fs.statSync(path);\n                }\n                result = stat.isFile();\n            }\n        } catch (e) {\n            result = false;\n        }\n\n        return result;\n    }\n    Y.Files.isFile = isFile;\n\n\n    /**\n    Check to see if this is a SymLink\n\n    @method isSymbolicLink\n    @param {Path} path The path to check\n    @return {Boolean} True if it is a link\n    **/\n    function isSymbolicLink(path) {\n        var stats = lstatSync(path);\n        return stats ? stats.isSymbolicLink() : false;\n    }\n    Y.Files.isSymbolicLink = isSymbolicLink;\n\n\n    /**\n    Like `fs.lstatSync()`, but returns `null` instead of throwing when _path_\n    doesn't exist. Will still throw on other types of errors.\n\n    @method lstatSync\n    @param {String} path Path to stat.\n    @return {fs.Stats|null} `fs.Stats` object, or `null` if _path_ doesn't exist.\n    **/\n    function lstatSync(path) {\n        try {\n            return fs.lstatSync(path);\n        } catch (ex) {\n            if (ex.code === 'ENOENT') {\n                return null;\n            }\n\n            throw ex;\n        }\n    }\n    Y.Files.lstatSync = lstatSync;\n\n\n    /**\n    Like `fs.statSync()`, but returns `null` instead of throwing when _path_\n    doesn't exist. Will still throw on other types of errors.\n\n    @method statSync\n    @param {String} path Path to stat.\n    @return {fs.Stats|null} `fs.Stats` object, or `null` if _path_ doesn't exist.\n    **/\n    function statSync(path) {\n        try {\n            return fs.statSync(path);\n        } catch (ex) {\n            if (ex.code === 'ENOENT') {\n                return null;\n            }\n\n            throw ex;\n        }\n    }\n    Y.Files.statSync = statSync;\n\n    /**\n    Copy the theme assets directory\n\n    @method copyAssets\n    @param {Path} from The source directory\n    @param {Path} dest The destination directory\n    @param {Boolean} deleteFirst Should the directory be deleted if it exists\n    @param {Function} callback The callback to be executed\n    */\n    function copyAssets() {\n        var args = Array.prototype.slice.call(arguments),\n            callback = args.pop(),\n            from = args.shift(),\n            to = args.shift(),\n            deleteFirst = args.shift();\n\n        if (from[0] === from[1]) {\n            if (isDirectory(from[0])) {\n                if (deleteFirst && isDirectory(to)) {\n                    deletePath(to);\n                }\n\n                copyPath(from[0], to, true, callback);\n            } else {\n                callback();\n            }\n        } else {\n            if (isDirectory(from[0])) {\n                if (deleteFirst && isDirectory(to)) {\n                    deletePath(to);\n                }\n\n                copyPath(from[0], to, true, function () {\n                    if (isDirectory(from[1])) {\n                        copyPath(from[1], to, true, callback);\n                    } else {\n                        callback();\n                    }\n                });\n            } else {\n                callback();\n            }\n\n        }\n    }\n    Y.Files.copyAssets = copyAssets;\n\n\n    /**\n    Helper method for getting JSON data from a local file\n\n    @method getJSON\n    @param {Path} filename The filename to parse JSON from\n    @return {Object} The JSON data\n    **/\n    Y.Files.getJSON = function (filename) {\n        var data = {};\n        if (exists(filename)) {\n            data = JSON.parse(fs.readFileSync(filename, 'utf8'));\n        }\n        return data;\n    };\n\n    /**\n    Helper method for writing files to disk. It wraps the NodeJS file API\n\n    @method writeFile\n    @param {Path} file The filename to write to\n    @param {String} data The data to write\n    @param {Callback} callback*\n    **/\n    function writeFile(file, data, cb) {\n        var out,\n            args = arguments,\n            flags = {\n                flags: 'w',\n                encoding: Y.charset,\n                mode: '0644'\n            };\n\n        if (cb) {\n            fs.writeFile(file, data, flags, function (err) {\n                if (err && err.message.match(/^EMFILE, Too many open files/)) {\n                    Y.log('Writefile failed, too many open files (' + args[0] + '). Trying again.', 'warn', 'files');\n                    writeFile.timer++;\n                    Y.later(writeFile.timer, Y, writeFile, args);\n                    return;\n                }\n                cb();\n            });\n        } else {\n            out = fs.createWriteStream(file, flags);\n            out.write(data);\n            out.end();\n        }\n    }\n    writeFile.timer = 100;\n\n    Y.Files.writeFile = writeFile;\n\n\n    function readFile(file, enc, cb) {\n        var args = arguments;\n        fs.readFile(file, enc, function (err, data) {\n            if (err && err.message.match(/^EMFILE, Too many open files/)) {\n                Y.log('Readfile failed, too many open files (' + args[0] + '). Trying again.', 'warn', 'files');\n                readFile.timer++;\n                Y.later(readFile.timer, Y, readFile, args);\n                return;\n            }\n            cb(err, data);\n        });\n    }\n    readFile.timer = 100;\n\n    Y.Files.readFile = readFile;\n\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/help.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nYUI.add('help', function (Y) {\n\n    /**\n     * Shows the help text\n     * @module yuidoc\n     * @class Help\n     */\n\n    /**\n     * The help text to display\n     * @private\n     * @property help\n     * @type Array\n     */\n    var help = [\n        '',\n        'YUI Doc generates API documentation from a modified JavaDoc syntax.',\n        '',\n        'Current version ({VERSION})',\n        '',\n        'Usage: yuidoc <options> <input path>',\n        '',\n        'Common Options:',\n        '  -c, --config, --configfile <filename>  A JSON config file to provide configuration data.',\n        '           You can also create a yuidoc.json file and place it',\n        '           anywhere under your source tree and YUI Doc will find it',\n        '           and use it.',\n        '  -e, --extension <comma sep list of file extensions> The list of file extensions to parse ',\n        '           for api documentation. (defaults to .js)',\n        '  -x, --exclude <comma sep list of directories> Directories to exclude from parsing ',\n        '           (defaults to \\'.DS_Store,.svn,CVS,.git,build_rollup_tmp,build_tmp\\')',\n        '  -v, --version Show the current YUIDoc version',\n        '  --project-version Set the doc version for the template',\n        '  -N, --no-color Turn off terminal colors (for automation)',\n        '  -C, --no-code Turn off code generation (don\\'t include source files in output)',\n        '  -n, --norecurse Do not recurse directories (default is to recurse)',\n        '  --no-sort Do not alphabetical sorting of attributes, events, methods, and properties',\n        '  -S, --selleck Look for Selleck component data and attach to API meta data',\n        '  -V, --view Dump the Handlebars.js view data instead of writing template files',\n        '  -p, --parse-only Only parse the API docs and create the JSON data, do not render templates',\n        '  -o, --outdir <directory path> Path to put the generated files (defaults to ./out)',\n        '  -t, --themedir <directory path> Path to a custom theme directory containing Handlebars templates',\n        '  -H, --helpers <comma separated list of paths to files> Require these file and add Handlebars helpers. See docs for more information',\n        '  --charset CHARSET Use this as the default charset for all file operations. Defaults to \\'utf8\\'',\n        '  -h, --help Show this help',\n        '  -q, --quiet Supress logging output',\n        '  -T, --theme <simple|default> Choose one of the built in themes (default is default)',\n        '  --syntaxtype <js|coffee> Choose comment syntax type (default is js)',\n        '  --server <port> Fire up the YUIDoc server for faster API doc developement. Pass optional port to listen on. (default is 3000)',\n        '  --lint Lint your docs, will print parser warnings and exit code 1 if there are any',\n        '',\n        '  <input path> Supply a list of paths (shell globbing is handy here)',\n        ''\n    ].join('\\n');\n\n    /**\n     * Render the help message as a string\n     * @method renderHelp\n     * @return {String} The help screen to display\n     */\n    Y.renderHelp = function () {\n        return Y.Lang.sub(help, {\n            VERSION: Y.packageInfo.version\n        });\n    };\n    /**\n     * Display the help message, write it to the screen and exit\n     * @method showHelp\n     */\n    Y.showHelp = function () {\n        console.error(Y.renderHelp());\n        process.exit(0); //Shouldn't exit one on help\n    };\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/options.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nYUI.add('options', function (Y) {\n\n    var path = require('path');\n\n    /**\n     * Handles argument parsing\n     * @module yuidoc\n     * @class Options\n     */\n\n    /**\n     * Parses arguments and returns an Object of config options\n     * @method Options\n     * @param {Array} args Arguments to parse\n     * @return {Object} The config object\n     */\n    Y.Options = function (args) {\n        var options = {\n            port: 3000,\n            nocode: false\n        };\n\n        while (args.length > 0) {\n            var v = args.shift();\n            // options.* defined in ./builder.js\n            switch (v) {\n            case '--lint':\n                options.lint = true;\n                options.parseOnly = true;\n                options.writeJSON = false;\n                options.quiet = true;\n                break;\n            case '--debug':\n                Y.applyConfig({\n                    debug: true,\n                    filter: 'debug'\n                });\n                break;\n            case '--charset':\n                Y.charset = args.shift() || 'utf8';\n                Y.log('Setting default charset to ' + Y.charset, 'yuidoc', 'warn');\n                break;\n            case '-c':\n            case '--config':\n            case '--configfile':\n                options.configfile = args.shift();\n                break;\n            case '-e':\n            case '--extension':\n                options.extension = args.shift();\n                break;\n            case '-x':\n            case '--exclude':\n                options.exclude = args.shift();\n                break;\n            case '-v':\n            case '--version':\n                console.error(Y.packageInfo.version);\n                process.exit(1);\n                break;\n            case '--project-version':\n                options.version = args.shift();\n                break;\n            case '-N':\n            case '--no-color':\n                Y.config.useColor = false;\n                options.nocolor = true;\n                break;\n            case '-D':\n            case '--no-delete-out':\n                options.nodeleteout = true;\n                break;\n            case '-C':\n            case '--no-code':\n                options.nocode = true;\n                break;\n            case '-n':\n            case '--norecurse':\n                options.norecurse = true;\n                break;\n            case '-S':\n            case '--selleck':\n                options.selleck = true;\n                break;\n            case '-V':\n            case '--view':\n                options.dumpview = true;\n                break;\n            case '-p':\n            case '--parse-only':\n                options.parseOnly = true;\n                break;\n            case '-o':\n            case '--outdir':\n                options.outdir = args.shift();\n                break;\n            case '-t':\n            case '--themedir':\n                options.themedir = args.shift();\n                break;\n            case '--server':\n                options.server = true;\n                var a = args.shift();\n                var p = parseInt(a, 10);\n                if (isNaN(p) || !p) {\n                    if (a) {\n                        args.unshift(a);\n                    }\n                    Y.log('Failed to extract port, setting to the default :3000', 'warn', 'yuidoc');\n                } else {\n                    options.port = p;\n                }\n                break;\n            case '-h':\n            case '--help':\n                Y.showHelp();\n                break;\n            case '-H':\n            case '--helpers':\n                var list = args.shift();\n                if (list) {\n                    options.helpers = list.split(',');\n                } else {\n                    throw ('Failed to pass a helper file.');\n                }\n                break;\n            case '-T':\n            case '--theme':\n                var theme = args.shift();\n                options.themedir = path.join(__dirname, '../', 'themes', theme);\n                break;\n            case '-q':\n            case '--quiet':\n                options.quiet = true;\n                break;\n            case '--syntaxtype':\n                options.syntaxtype = args.shift();\n                break;\n            case '--tab-to-space':\n                options.tabtospace = parseInt(args.shift(), 10);\n                if (typeof options.tabtospace === 'number') {\n                    options.tabspace = '';\n                    for (var s = 0; s < options.tabtospace; s++) {\n                        options.tabspace += ' ';\n                    }\n                }\n                break;\n            case '--no-sort':\n                options.dontsortfields = true;\n                break;\n            default:\n                if (!options.paths) {\n                    options.paths = [];\n                }\n                if (v && v.indexOf('-') === 0) {\n                    throw ('Unknown option: ' + v);\n                }\n                options.paths.push(v);\n            }\n        }\n\n        if (options.quiet) {\n            Y.applyConfig({\n                debug: false\n            });\n        }\n\n        return options;\n    };\n\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/project.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nYUI.add('project', function (Y) {\n\n    Y.Project = {\n        mix: function (json, options) {\n            if (json.project) {\n                options = Y.merge(options, json.project);\n            }\n\n            if (options.title && !options.name) {\n                options.name = options.title;\n            }\n\n            return options;\n        },\n        init: function (options) {\n            var project = {};\n            if (options.configfile) {\n                project = Y.Files.getJSON(options.configfile);\n            } else {\n                Y.log('Scanning for yuidoc.json file.', 'info', 'yuidoc');\n                project = Y.getProjectData();\n                if (!project) {\n                    project = {};\n                }\n            }\n\n            if (project.options && Object.keys(project.options).length) {\n                options = Y.merge(project.options, options);\n                delete project.options;\n                options.project = project;\n            }\n\n            if (options.version && options.project) {\n                options.project.version = options.version;\n                delete options.version;\n            }\n\n            if (!options.outdir) {\n                options.outdir = './out';\n            }\n\n            options.paths = Y.validatePaths(options.paths, options.ignorePaths);\n\n            if (!options.paths.length) {\n                Y.log('Paths argument was empty', 'warn', 'yuidoc');\n                Y.showHelp();\n                process.exit(1);\n            }\n\n            if (typeof options.tabtospace === 'number') {\n                options.tabspace = '';\n                for (var s = 0; s < options.tabtospace; s++) {\n                    options.tabspace += ' ';\n                }\n            }\n\n            return options;\n        }\n    };\n\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/server.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nvar path = require('path');\nvar express = require('express');\n\nYUI.add('server', function (Y) {\n\n    /**\n     * Provides the `--server` server option for YUIDoc\n     * @class Server\n     * @module yuidoc\n     */\n    var Server = {\n        /**\n         * Cache for external mixed in data.\n         * @property _externalData\n         * @private\n         * @type Object\n         */\n        _externalData: null,\n        /**\n         * Middleware to parse the API docs per request\n         * @method parse\n         * @param {Request} req Express request object\n         * @param {Response} res Express response object\n         * @param {Function} next Express next callback\n         */\n        parse: function (req, res, next) {\n            var json = (new Y.YUIDoc(Server.options)).run();\n            Server.options = Y.Project.mix(json, Server.options);\n            Server.builder = new Y.DocBuilder(Server.options, json);\n            if (Server._externalData) {\n                Server.options.externalData = Server._externalData;\n                Server.builder._mixExternal();\n            }\n\n            next();\n        },\n        /**\n         * Create the routes used to serve YUIDoc files dynamically\n         * @method routes\n         */\n        routes: function () {\n            var app = Server.app;\n\n            app.get('/', Server.parse, function (req, res) {\n                Server.home(req, res);\n            });\n            app.get('/api.js', function (req, res) {\n                Server.builder.renderAPIMeta(function (js) {\n                    res.contentType('.js');\n                    res.send(js);\n                });\n            });\n\n\n            app.get('/classes/:class.html', Server.parse, function (req, res, next) {\n                Server.clazz(req, res, next);\n            });\n\n            app.get('/modules/:module.html', Server.parse, function (req, res, next) {\n                Server.module(req, res, next);\n            });\n\n            app.get('/files/:file.html', Server.parse, function (req, res, next) {\n                Server.files(req, res, next);\n            });\n\n            //These routes are special catch routes..\n\n            app.get('//api.js', function (req, res) {\n                res.redirect('/api.js');\n            });\n            app.get('//classes/:class.html', Server.parse, function (req, res, next) {\n                Server.clazz(req, res, next);\n            });\n\n            app.get('//modules/:module.html', Server.parse, function (req, res, next) {\n                Server.module(req, res, next);\n            });\n\n            app.get('//files/:file.html', Server.parse, function (req, res, next) {\n                Server.files(req, res, next);\n            });\n\n            app.get('*', function (req, res) {\n                var type = req.url.split('/')[1],\n                    html = ['<h1>Item Not Found in internal meta-data</h1>'];\n\n                if (type === 'class') {\n                    type = 'classes';\n                }\n                if (Server.builder && Server.builder.data && Server.builder.data[type]) {\n                    if (Object.keys(Server.builder.data[type]).length) {\n                        html.push('<p>But I know about these? Misname your module?</p>');\n                        html.push('<ul>');\n                        Object.keys(Server.builder.data[type]).forEach(function (item) {\n                            html.push('<li><a href=\"../' + path.dirname(req.url) + '/' + item + '.html\">' + item + '</a></li>');\n                        });\n                        html.push('</ul>');\n                    }\n                }\n\n\n                res.status(404).send(html.join('\\n'));\n            });\n\n        },\n        /**\n         * `/files` endpoint\n         * @method files\n         * @param {Request} req Express request object\n         * @param {Response} res Express response object\n         */\n        files: function (req, res, next) {\n            var fileName = req.params.file,\n                data;\n            Object.keys(Server.builder.data.files).forEach(function (file) {\n                if (fileName === Server.builder.filterFileName(file)) {\n                    data = Server.builder.data.files[file];\n                }\n            });\n\n            if (!data) {\n                return next();\n            }\n\n            Y.log('Serving /files/' + data.name, 'info', 'server');\n\n\n            Server.builder.renderFile(function (html) {\n                res.send(html);\n            }, data, (req.xhr ? 'xhr' : 'main'));\n        },\n        /**\n         * `/classes` endpoint\n         * @method clazz\n         * @param {Request} req Express request object\n         * @param {Response} res Express response object\n         */\n        clazz: function (req, res, next) {\n            var className = req.params.class;\n            Y.log('Serving /classes/' + className + '.html', 'info', 'server');\n            if (!Server.builder.data.classes[className]) {\n                return next();\n            }\n            Server.builder.renderClass(function (html) {\n                res.send(html);\n            }, Server.builder.data.classes[className], (req.xhr ? 'xhr' : 'main'));\n        },\n        /**\n         * `/modules` endpoint\n         * @method modules\n         * @param {Request} req Express request object\n         * @param {Response} res Express response object\n         */\n        module: function (req, res, next) {\n            var modName = req.params.module;\n            Y.log('Serving /modules/' + modName + '.html', 'info', 'server');\n            if (!Server.builder.data.modules[modName]) {\n                return next();\n            }\n            Server.builder.renderModule(function (html) {\n                res.send(html);\n            }, Server.builder.data.modules[modName], (req.xhr ? 'xhr' : 'main'));\n        },\n        /**\n         * `/` endpoint\n         * @method home\n         * @param {Request} req Express request object\n         * @param {Response} res Express response object\n         */\n        home: function (req, res) {\n            Y.log('Serving index.html', 'info', 'server');\n            Server.builder.renderIndex(function (html) {\n                res.send(html);\n            });\n        },\n        /**\n         * Creates the Express server and prep's YUI for serving\n         * @method init\n         */\n        init: function () {\n            var stat;\n\n            Server.app = express();\n            //console.log(Server.options);\n            stat = Server.options.themedir || path.join(__dirname, '../', 'themes', 'default');\n            Server.app.use(express.static(stat));\n            Server.routes();\n            Server.app.listen(Server.options.port);\n\n            Y.log('Starting server: http:/' + '/127.0.0.1:' + Server.options.port, 'info', 'server');\n        },\n        /**\n         * Start the server with the supplied options.\n         * @method start\n         * @param {Object} options Server options\n         */\n        start: function (options) {\n            options = Y.Project.init(options);\n            Server.options = options;\n\n            Server.options.cacheTemplates = false; //Don't cache the Handlebars templates\n            Server.options.writeJSON = false; //Don't write the JSON file out\n\n            Y.config.logExclude.yuidoc = true;\n            Y.config.logExclude.docparser = true;\n            Y.config.logExclude.builder = true;\n\n            if (Server.options.external) {\n                Y.log('Fetching external data, this may take a minute', 'warn', 'server');\n                var json, builder;\n\n                json = (new Y.YUIDoc(Server.options)).run();\n                Server.options = Y.Project.mix(json, Server.options);\n\n                builder = new Y.DocBuilder(Server.options, json);\n                builder.mixExternal(function () {\n                    Y.log('External data fetched, launching server..', 'info', 'server');\n                    Server._externalData = builder.options.externalData;\n                    Server.init();\n                });\n\n            } else {\n                Server.init();\n            }\n        }\n    };\n\n    Y.Server = Server;\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/utils.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nvar path = require('path'),\n    minimatch = require('minimatch'),\n    fs = require('graceful-fs');\n\n/**\n * Utilities Class\n * @class Utils\n * @module yuidoc\n */\n\nYUI.add('utils', function (Y) {\n\n    Y.charset = 'utf8';\n\n    var HTML_CHARS = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        '\\'': '&#x27;',\n        '/': '&#x2F;',\n        '`': '&#x60;'\n    };\n\n    /**\n    Escapes HTML characters in _html_.\n\n    @method escapeHTML\n    @param {String} html String to escape.\n    @return {String} Escaped string.\n    **/\n    Y.escapeHTML = function (html) {\n        return html.replace(/[&<>\"'\\/`]/g, function (match) {\n            return HTML_CHARS[match];\n        });\n    };\n\n    /**\n    Normalizes the initial indentation of the given _content_ so that the first line\n    is unindented, and all other lines are unindented to the same degree as the\n    first line. So if the first line has four spaces at the beginning, then all\n    lines will be unindented four spaces.\n\n    @method unindent\n    @param {String} content Text to unindent.\n    @return {String} Unindented text.\n    @private\n    **/\n    Y.unindent = function (content) {\n        var indent = content.match(/^(\\s+)/);\n\n        if (indent) {\n            content = content.replace(new RegExp('^' + indent[1], 'gm'), '');\n        }\n\n        return content;\n    };\n\n    /**\n    Like `getPages()`, but returns only the files under the `layout/` subdirectory\n    of the specified _dir_.\n\n    @method getLayouts\n    @param {String} dir Directory path.\n    @return {Object} Mapping of layout names to layout content.\n    **/\n    function getLayouts(dir) {\n        return getPages(path.join(dir, 'layouts'));\n    }\n    Y.getLayouts = getLayouts;\n\n    /**\n    Loads and returns the content of the specified page file.\n\n    @method getPage\n    @param {String} pagePath Path to a single `.handlebars` page.\n    @return {String|null} Page content, or `null` if not found.\n    **/\n    function getPage(pagePath) {\n        if (!Y.Files.isFile(pagePath)) {\n            return null;\n        }\n        return fs.readFileSync(pagePath, Y.charset);\n    }\n    Y.getPage = getPage;\n\n    /**\n    Loads pages (files with a `.handlebars` extension) in the specified directory and\n    returns an object containing a mapping of page names (the part of the filename)\n    preceding the `.handlebars` extension) to page content.\n\n    @method getPages\n    @param {String} dir Directory path.\n    @return {Object} Mapping of page names to page content.\n    **/\n    var cache = {};\n    function getPages(dir) {\n        if (cache[dir]) {\n            return cache[dir];\n        }\n        var pages = {};\n\n        if (!Y.Files.isDirectory(dir)) {\n            return pages;\n        }\n\n        fs.readdirSync(dir).forEach(function (filename) {\n            var filePath = path.join(dir, filename);\n\n            if (path.extname(filename) === '.handlebars' && Y.Files.isFile(filePath)) {\n                pages[path.basename(filename, '.handlebars')] = fs.readFileSync(filePath, Y.charset);\n            }\n        });\n        cache[dir] = pages;\n\n        return pages;\n    }\n    Y.getPages = getPages;\n\n    /**\n    Like `getPages()`, but returns only the files under the `partial/` subdirectory\n    of the specified _dir_.\n\n    @method getPartials\n    @param {String} dir Directory path.\n    @return {Object} Mapping of partial names to partial content.\n    **/\n    function getPartials(dir) {\n        return getPages(path.join(dir, 'partials'));\n    }\n    Y.getPartials = getPartials;\n\n\n    /**\n    Mix/merge/munge data into the template.\n\n    @method prepare\n    @param {String} inDir The starting directory\n    @param {Object} options The `options` for the meta data.\n    @param {callback} callback The callback to excecute when complete\n    @param {Error} callback.err\n    @param {Object} callback.options Merged options.\n    **/\n    function prepare(inDirs, options, callback) {\n        var layouts,\n            partials,\n            type = 'project';\n\n        if (options && options.skipLoad) {\n            // Skip loading layouts, metadata, pages, and partials and assume that\n            // the caller has provided them if they want them.\n            options = Y.merge({\n                layouts: {},\n                meta: {},\n                pages: {},\n                partials: {},\n                viewClass: Y.DocView\n            }, options);\n        } else {\n            // Gather layouts, metadata, pages, and partials from the specified\n            // input directory, then merge them into the provided options (if any).\n            //\n            // Gathered data will override provided data if there are conflicts, in\n            // order to support a use case where global data are provided by the\n            // caller and overridden by more specific component-level data gathered\n            // from the input directory.\n            //\n            // The metadata inheritance chain looks like this:\n            //\n            //   - override metadata specified via CLI (highest precedence)\n            //   - component metadata (if this is a component)\n            //   - project-level component default metadata (if specified and this is a component)\n            //   - theme-level component default metadata (if specified and this is a component)\n            //   - project metadata\n            //   - theme metadata (lowest precedence)\n            try {\n                if (inDirs[0] === inDirs[1]) {\n                    layouts = getLayouts(inDirs[0]);\n                    partials = getPartials(inDirs[0]);\n                } else {\n                    layouts = Y.merge(getLayouts(inDirs[0]), getLayouts(inDirs[1]));\n                    partials = Y.merge(getPartials(inDirs[0]), getPartials(inDirs[1]));\n                }\n                options = Y.merge({\n                        viewClass: Y.DocView\n                    },\n                    options || {}, {\n                        layouts: layouts,\n                        meta: options.meta,\n                        partials: partials\n                    }\n                );\n            } catch (ex) {\n                return callback(ex);\n            }\n        }\n\n        // Mix in the override metadata, if any. It takes precedence over everything\n        // else.\n        Y.mix(options.meta, options.overrideMeta);\n\n        // Set a default asset path if one isn't specified in the metadata.\n        if (!options.meta.projectAssets) {\n            options.meta.projectAssets = options.component ? '../assets' : 'assets';\n        }\n\n        if (!options.meta.componentAssets && options.component) {\n            options.meta.componentAssets = '../assets/' + options.meta.name;\n        }\n\n        if (typeof options.meta.layout === 'undefined') {\n            options.meta.layout = options.layouts[type] ? type : 'main';\n        }\n\n        callback(null, options);\n    }\n\n    Y.prepare = prepare;\n\n    /**\n     * Walk the directory tree to locate the yuidoc.json file.\n     * @method getProjectData\n     * @param {Path} [directory=process.cwd()] The directory to start from\n     */\n    var getProjectData = function (directory) {\n        var dirs = [directory || process.cwd()];\n        var projectData, packageData;\n        var dirCount = 0;\n        // keep looping until\n        //  * data is found\n        //  * there are no more dirs to process\n        //  * we abort due to failsafe\n        while (dirs.length && !projectData) {\n            if (dirCount++ > 5000) {\n                Y.log('Scanned ' + dirCount + ' directories looking for a yuidoc.json file, something is probably wrong here..', 'error', 'yuidoc');\n                process.exit(1);\n            }\n            // accumulator for directories at this level\n            var childDirs = [];\n            // for each directory at the previous level\n            dirs.forEach(function (dir) {\n                // abort iterating if we have project data\n                if (projectData) {\n                    return;\n                }\n                // squelch (but log) any complaints about this particular directory\n                try {\n                    // for each item in this directory\n                    var names = fs.readdirSync(dir);\n                    names.forEach(function (name) {\n                        // abort iterating a folder if we have found both data\n                        if (projectData && packageData) {\n                            return;\n                        }\n                        // build a full path\n                        var p = path.join(dir, name);\n                        // acquire project data from this item if possible\n                        if (Y.Files.isFile(p)) {\n                            projectData = getFileData(p, name, 'yuidoc.json');\n                            // 'package.json' is used for auxilliary configuration\n                            // if it's found. Formerly, it was only found if it\n                            // came _before_'yuidoc.json' in the folder tree\n                            // (never in the same folder).\n                            // This code will find 'package.json' in the same\n                            // folder as 'yuidoc.json'.\n                            // If there is no 'yuidoc.json', former algorithm would\n                            // use the deepest 'package.json' it can find, this one\n                            // will use the first (most shallow) one.\n                            packageData = packageData || getFileData(p, name, 'package.json');\n                        }\n                        // if we are a folder, but not ., .., or node_modules,\n                        // then add to directory accumulator\n                        if (Y.Files.isDirectory(p)) {\n                            if (name.indexOf('.') === 0) {\n                                return;\n                            }\n                            if (name === 'node_modules') {\n                                Y.log('Skipping node_modules directory while scanning for yuidoc.json', 'warn', 'yuidoc');\n                                return;\n                            }\n                            childDirs.push(p);\n                        }\n                    });\n                } catch (dirPerm) {\n                    Y.log('Accessing dir (' + dir + ') threw an error', 'warn', 'yuidoc');\n                }\n            });\n            // iterate over new set of folders\n            dirs = childDirs;\n        }\n        if ((packageData && projectData) || (packageData && packageData.yuidoc)) {\n            projectData = mergeData(packageData, projectData);\n        }\n        return projectData;\n    };\n\n    var getFileData = function (p, name, file) {\n        if (name === file) {\n            Y.log('Loading ' + name + ' data from: ' + p, 'info', 'yuidoc');\n            try {\n                return Y.Files.getJSON(p);\n            } catch (e) {\n                var err = 'Failed to parse ' + name + ' file, please make sure it is valid JSON';\n                Y.log(err, 'error', 'yuidoc');\n                throw (e + '');\n            }\n        }\n    };\n\n    var mergeData = function (pack, project) {\n        project = project || {};\n\n        if (pack.yuidoc) {\n            Object.keys(pack.yuidoc).forEach(function (key) {\n                if (!project[key]) {\n                    project[key] = pack.yuidoc[key];\n                }\n            });\n        }\n\n        ['name', 'description', 'version', 'url'].forEach(function (key) {\n            if (pack[key] && !project[key]) {\n                project[key] = pack[key];\n            }\n        });\n\n        return project;\n    };\n\n    Y.getProjectData = getProjectData;\n\n    /**\n     * Walks the tree from this dir and returns all the subdirs\n     * @method getDirs\n     * @param {String} baseDir The dir to begin at\n     * @param {Array} ignore An array of paths to ignore\n     * @return {Array} The array of directories..\n     */\n    var getDirs = function (baseDir, ignore) {\n        var inputPaths = [],\n            paths = [],\n            i, d, isIgnored, subpath,\n            stat, possibleDirs, fullPath;\n\n        var inputPath = '';\n        while (inputPath !== undefined) {\n            fullPath = path.join(baseDir, inputPath);\n            stat = fs.lstatSync(fullPath);\n\n            if (stat.isDirectory()) {\n                if (fullPath !== baseDir) {\n                    paths.push(fullPath);\n                }\n                possibleDirs = fs.readdirSync(fullPath);\n                for (d=0;d<possibleDirs.length;d++) {\n                    subpath = path.join(inputPath, possibleDirs[d]);\n                    isIgnored = false;\n                    for (i=0;i<ignore.length;i++) {\n                        if (subpath.indexOf(ignore[i]) === 0) {\n                          isIgnored = true;\n                          break;\n                        }\n                    }\n                    if (!isIgnored) {\n                      inputPaths.push(subpath);\n                    }\n                }\n            }\n            inputPath = inputPaths.pop();\n        }\n\n        return paths;\n    };\n\n    Y.getDirs = getDirs;\n\n    /**\n     * Make sure all the paths passed are directories and that they are not in the ignore list.\n     * @method validatePaths\n     * @param {Array} paths The array of paths to validate\n     * @param {String} [ignore=false] A string to call `.indexOf` on a path to determine if it should be ignored\n     */\n    var validatePaths = function (paths, ignore) {\n        if (!ignore) {\n            ignore = [];\n        } else if (!(ignore instanceof Array)) {\n            ignore = [ignore];\n        }\n\n        var newpaths = [];\n        //Shortcut the *, . & ./ shortcuts that shall globbing fixes for us\n        if (paths === '*' || paths === '.' || paths === './') {\n            paths = [process.cwd()];\n        }\n\n        // Ensure that we always have an array of some kind.\n        paths = paths || [];\n        if (!Y.Lang.isArray(paths)) {\n            paths = [paths];\n        }\n        paths.forEach(function (validatePath) {\n            var glob = validatePath || '';\n\n            if (process.platform === 'win32') {\n                glob = validatePath.replace(/\\//g, '\\\\\\\\');\n            }\n\n            var glob_paths = getDirs('.', ignore),\n                is_globbed = false;\n\n            glob_paths.forEach(function (dir) {\n                //Don't scan things in node_modules\n                if (dir.indexOf('node_modules') > -1) {\n                    return;\n                }\n                if (minimatch(dir, glob, {\n                    period: true\n                })) {\n                    newpaths.push(dir);\n                    is_globbed = true;\n                }\n            });\n\n            if (!is_globbed && (Y.Files.isDirectory(glob))) {\n                //If minimatch fails, check to see if it's a relative directory\n                // if it is, add it directly\n                newpaths.push(glob);\n            }\n        });\n\n        paths = newpaths;\n        paths.forEach(function (newPath) {\n            try {\n                if (!Y.Files.isDirectory(newPath)) {\n                    throw ('Path not a directory: ' + newPath);\n                }\n            } catch (e) {\n                throw new Error(e.message);\n            }\n        });\n\n        if (!paths || !paths.forEach) {\n            throw ('Paths should be an array of paths');\n        }\n\n        paths = paths.sort();\n        return paths;\n    };\n\n    Y.validatePaths = validatePaths;\n\n    /**\n     * Takes a type string and converts it to a \"First letter upper cased\" type. e.g. `(string -> String, object -> Object)`\n     * @method fixType\n     * @param {String} t The type string to convert\n     * @return {String} The fixed string\n     */\n    var fixType = function (t) {\n        if (t && t.indexOf('.') === -1) {\n            t = t.replace(/{/g, '').replace(/}/g, '');\n            var firstChar = t.charAt(0),\n                upperFirstChar = firstChar.toUpperCase();\n\n            if (firstChar !== upperFirstChar) {\n                return upperFirstChar + t.substring(1);\n            }\n        }\n\n        return t;\n    };\n\n    Y.Lang.fixType = fixType;\n\n    /**\n     * Produces a normalized web path by joining all the parts and normalizing the\n     * filesystem-like path into web compatible url.\n     * Supports relative and absolute paths.\n     * Courtesy of [Mojito's utils](https://github.com/yahoo/mojito/)\n     *\n     * @method webpath\n     * @param {Array|String*} url the list of parts to be joined and normalized\n     * @return {String} The joined and normalized url\n     **/\n    function webpath() {\n        var args = [].concat.apply([], arguments),\n            parts = path.join.apply(path, args).split(/[\\\\\\/]/);\n        return parts.join('/');\n    }\n\n    Y.webpath = webpath;\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/lib/yuidoc.js":"/**\n * Copyright (c) 2011, Yahoo! Inc. All rights reserved.\n * Code licensed under the BSD License:\n * https://github.com/yui/yuidoc/blob/master/LICENSE\n */\n'use strict';\n\nvar fs = require('graceful-fs');\nvar rimraf = require('rimraf');\nvar path = require('path');\n\n/**\nThis is the __module__ description for the `YUIDoc` module.\n\n    var options = {\n        paths: [ './lib' ],\n        outdir: './out'\n    };\n\n    var Y = require('yuidocjs');\n    var json = (new Y.YUIDoc(options)).run();\n\n@class YUIDoc\n@main yuidoc\n*/\n\n\nYUI.add('yuidoc', function (Y) {\n\n\n    /**\n     * The default list of configuration options\n     * @property OPTIONS\n     * @type Object\n     * @final\n     * @for YUIDoc\n     */\n    var OPTIONS = {\n        quiet: false,\n        writeJSON: true,\n        outdir: path.join(process.cwd(), 'out'),\n        extension: '.js',\n        exclude: '.DS_Store,.svn,CVS,.git,build_rollup_tmp,build_tmp,node_modules',\n        norecurse: false,\n        version: '0.1.0',\n        paths: [],\n        themedir: path.join(__dirname, 'themes', 'default'),\n        syntaxtype: 'js'\n    };\n\n    /**\n     * YUIDoc main class\n\n        var options = {\n            paths: [ './lib' ],\n            outdir: './out'\n        };\n\n        var Y = require('yuidoc');\n        var json = (new Y.YUIDoc(options)).run();\n\n     * @class YUIDoc\n     * @module yuidoc\n     * @constructor\n     * @param config The config object\n     */\n    Y.YUIDoc = function (config) {\n        /**\n         * Holds the number of files that we are processing.\n         * @property filecount\n         * @type Boolean\n         * @private\n         */\n        this.filecount = 0;\n        /**\n         * Hash map of dirnames to selleck config options.\n         * @property selleck\n         * @type Object\n         * @private\n         */\n        this.selleck = {};\n        /**\n         * Holder for the list of files we are processing.\n         * @property filemap\n         * @type Object\n         * @private\n         */\n        this.filemap = {};\n        /**\n         * Holder for the list of directories we are processing.\n         * @property dirmap\n         * @type Object\n         * @private\n         */\n        this.dirmap = {};\n\n        /**\n         * Internal holder for configuration options.\n         * @property options\n         * @type Object\n         * @private\n         */\n        this.options = Y.merge(OPTIONS, config);\n\n        if (this.options.quiet) {\n            Y.applyConfig({\n                debug: false\n            });\n        }\n\n    };\n\n    Y.YUIDoc.prototype = {\n        /**\n         * Always exclude these directories\n         * @method _setDefaultExcludes\n         * @private\n         */\n        _setDefaultExcludes: function () {\n            //These should always be excluded\n            var excludes = '.DS_Store,.svn,CVS,.git,build_rollup_tmp,build_tmp,node_modules'.split(','),\n                self = this;\n\n            excludes.forEach(function (item) {\n                self.options.excludes[item] = true;\n            });\n        },\n\n        /**\n         * Does post process on self.options.\n         * @method _processConfig\n         * @private\n         */\n        _processConfig: function () {\n            this.options.extensions = Y.Array.hash(this.options.extension.split(','));\n            this.options.excludes = Y.Array.hash(this.options.exclude.split(','));\n            this._setDefaultExcludes();\n        },\n\n        /**\n         * Walks the paths and parses the directory contents\n         * @method walk\n         * @private\n         */\n        walk: function () {\n            Y.each(this.options.paths, function (dir) {\n                this.parsedir(dir);\n            }, this);\n        },\n\n        /**\n         * Walks the passed directory and grabs all the files recursively.\n         * @method parsedir\n         * @param {String} dir The directory to parse the contents of.\n         * @private\n         */\n        parsedir: function (dir) {\n            if (!Y.Files.isDirectory(dir)) {\n                throw ('Can not find directory: ' + dir);\n            }\n\n            var allfiles = fs.readdirSync(dir),\n                stats,\n                files = [],\n                fullpath, self = this;\n\n            if (dir in self.options.excludes) {\n                return;\n            }\n\n            allfiles = allfiles.sort();\n\n            Y.each(allfiles, function (filename) {\n                if (!(filename in self.options.excludes)) {\n                    fullpath = path.join(dir, filename);\n\n                    stats = fs.statSync(fullpath);\n\n                    if (stats.isDirectory() && !self.options.norecurse) {\n                        self.parsedir(fullpath);\n                    } else {\n                        files.push(filename);\n                    }\n                }\n            });\n\n            if (!(dir in self.options.excludes)) {\n                this.parsefiles(dir, files);\n            }\n        },\n\n        /**\n         * Gathers all the file data and populates the filemap and dirmap hashes.\n         * @method parsefiles\n         * @param {String} dir The directory to start from.\n         * @param {Array} files List of files to parse.\n         * @private\n         */\n        parsefiles: function (dir, files) {\n            var self = this;\n            files = files.sort();\n\n            Y.each(files, function (filename) {\n                var ext = path.extname(filename),\n                    text,\n                    fullpath;\n\n                if (ext) {\n                    if (ext in self.options.extensions) {\n                        fullpath = path.join(dir, filename);\n\n                        if (Y.Files.exists(fullpath)) {\n                            self.filecount++;\n                            text = fs.readFileSync(fullpath, Y.charset);\n\n                            self.filemap[fullpath] = text.replace(/\\r?\\n|\\r/g, '\\n');\n                            self.dirmap[fullpath] = dir;\n                            self.getSelleck(fullpath);\n\n                        } else {\n                            Y.log('File skipped: ' + fullpath, 'warn', 'yuidoc');\n                        }\n                    }\n                }\n            });\n        },\n\n        getSelleck: function (fullpath) {\n            var self = this,\n                base,\n                comp,\n                json;\n\n            if (self.options.selleck) {\n                base = path.dirname(fullpath);\n                comp = path.join(base, '../', 'docs', 'component.json');\n                //Y.log('Checking for Selleck data: ' + comp, 'info', 'yuidoc');\n                if (Y.Files.exists(comp)) {\n                    try {\n                        json = JSON.parse(fs.readFileSync(comp, 'utf8'));\n                        delete json.examples; //Remove the selleck example data, we only want the comp info\n                        self.selleck[fullpath] = json;\n                    } catch (e) {\n                        Y.log('JSON parse failed on Selleck component.json file: ' + comp, 'error', 'yuidoc');\n                    }\n                }\n            }\n        },\n\n        /**\n         * Applies preprocessors to the data tree.\n         * This function first clones the data and operates on the clone.\n         * @method runPreprocessors\n         * @private\n         * @return {Object} The mutated data\n         */\n        runPreprocessors: function (data) {\n            var self = this,\n                preprocessors,\n                preprocessorsRelativeTo;\n\n            // We will try to load the preprocessors as npm modules, but we will also\n            // search for them relative to the process working directory.\n            // The latter is consistent with how other paths are treated by yuidoc,\n            // such as the config options 'paths' and 'outdir'.\n            preprocessorsRelativeTo = process.cwd();\n\n            if (self.options.preprocessor) {\n                data = JSON.parse(JSON.stringify(data));\n\n                preprocessors = [].concat(self.options.preprocessor);\n\n                preprocessors.forEach(function (preprocessor) {\n                    var preprocessorModule;\n\n                    try {\n                        preprocessorModule = require(preprocessor);\n                    } catch (e) {\n                        preprocessorModule = require(path.resolve(preprocessorsRelativeTo, preprocessor));\n                    }\n\n                    preprocessorModule(data, self.options);\n                });\n            }\n\n            return data;\n        },\n\n        /**\n         * Writes the parser JSON data to disk.\n         * Applies preprocessors, if any.\n         * @method writeJSON\n         * @param {Object} parser The DocParser instance to use\n         * @private\n         * @return {Object} The JSON data returned from the DocParser\n         */\n        writeJSON: function (parser) {\n            var self = this,\n                data,\n                file,\n                out;\n\n            data = parser.data;\n\n            data.warnings = parser.warnings;\n\n            data = this.runPreprocessors(data);\n\n            if (self.selleck && self.options.selleck && data.files && data.modules) {\n                Object.keys(self.selleck).forEach(function (selleckFile) {\n                    Object.keys(data.files).forEach(function (f) {\n                        if (selleckFile === f) {\n                            var mods = data.files[f].modules;\n                            if (mods) {\n                                Object.keys(mods).forEach(function (mod) {\n                                    if (data.modules[mod]) {\n                                        if (!data.modules[mod].extra) {\n                                            data.modules[mod].extra = {};\n                                        }\n                                        data.modules[mod].extra.selleck = self.selleck[selleckFile];\n                                    }\n                                });\n                            }\n                        }\n                    });\n                });\n            }\n\n            if (self.options.project) {\n                data.project = self.options.project;\n            }\n\n            if (self.options.writeJSON) {\n                // Y.log(Y.JSON.stringify(parser.data, null, 4));\n                file = path.join(self.options.outdir, 'data.json');\n\n                if (Y.Files.exists(self.options.outdir) && !self.options.nodeleteout) {\n                    Y.log('Found out dir, deleting: ' + self.options.outdir, 'warn', 'yuidoc');\n                    rimraf.sync(self.options.outdir);\n                }\n\n                if (!Y.Files.exists(self.options.outdir)) {\n                    Y.log('Making out dir: ' + self.options.outdir, 'info', 'yuidoc');\n                    try {\n                        fs.mkdirSync(self.options.outdir, '0777');\n                    } catch (e) {\n                        Y.log('Outdir creation failed', 'warn', 'yuidoc');\n                    }\n                }\n\n                out = fs.createWriteStream(file, {\n                    flags: 'w',\n                    encoding: Y.charset,\n                    mode: '0644'\n                });\n                out.write(JSON.stringify(data, null, 4));\n                out.end();\n            }\n\n            return data;\n        },\n\n        lint: function (warnings) {\n            var code = 0,\n                count = 0;\n\n            if (warnings && warnings.length) {\n                code = 1;\n                console.log('YUIDoc found', warnings.length, 'lint errors in your docs');\n                warnings.forEach(function (item) {\n                    count++;\n                    console.log('#' + count, item.message, item.line + '\\n');\n                });\n                process.exit(code);\n            }\n        },\n\n        /**\n         * Process the config, walk the file tree and write out the JSON data.\n         * @method run\n         * @return {Object} The JSON data returned from the DocParser\n         */\n        run: function () {\n            /**\n             * Timestamp holder so we know when YUIDoc started the parse process.\n             * @property starttime\n             * @type Timestamp\n             */\n            Y.log('YUIDoc Starting from: ' + this.options.paths.join(','), 'info', 'yuidoc');\n            this.starttime = new Date().getTime();\n\n            this._processConfig();\n            this.walk();\n\n            var json = this.writeJSON(new Y.DocParser({\n                syntaxtype: this.options.syntaxtype,\n                filemap: this.filemap,\n                dirmap: this.dirmap\n            }).parse());\n\n            if (this.options.lint) {\n                this.lint(json.warnings);\n                return null;\n            }\n\n            /**\n             * Timestamp holder so we know when YUIDoc has finished the parse process.\n             * @property endtime\n             * @type Timestamp\n             */\n            this.endtime = new Date().getTime();\n            Y.log('Parsed ' + this.filecount + ' files in ' + ((this.endtime - this.starttime) / 1000) + ' seconds', 'info', 'yuidoc');\n\n            return json;\n        }\n    };\n\n});\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/scripts/report.js":"#!/usr/bin/env node\n\nvar istanbul = require('istanbul');\nvar fs = require('fs');\nvar path = require('path');\nvar json = JSON.parse(fs.readFileSync(path.join(__dirname, '../coverage/test-coverage.json')));\n\nvar collect = new istanbul.Collector(),\n    report = istanbul.Report.create('text'),\n    summary = istanbul.Report.create('text-summary');\n\n    collect.add(json);\n\nreport.writeReport(collect);\nsummary.writeReport(collect);\n","/home/travis/build/npmtest/node-npmtest-yuidocjs/node_modules/yuidocjs/scripts/versions.js":"#!/usr/bin/env node\n\nvar path = require('path'),\n    fs = require('fs'),\n    package = require(path.join(__dirname, '../', 'package.json')),\n    version = package.version,\n    doc = path.join(__dirname, '../', 'conf', 'docs', 'project.json');\n\nconsole.log('[version]', version);\nconsole.log('[doc]', doc);\n\nvar docJSON = require(doc);\n\ndocJSON.version = version;\n\nfs.writeFileSync(doc, JSON.stringify(docJSON, null, 2));\nconsole.log('[done]');\n"}